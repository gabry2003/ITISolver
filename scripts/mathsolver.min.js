/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_js_mathsolver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/js/mathsolver */ \"./src/js/mathsolver.js\");\n/* harmony import */ var _src_js_grafico__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/js/grafico */ \"./src/js/grafico.js\");\n\n\n\nwindow.MathSolver = _src_js_mathsolver__WEBPACK_IMPORTED_MODULE_0__.MathSolver;\nwindow.Grafico = _src_js_grafico__WEBPACK_IMPORTED_MODULE_1__.Grafico;\n\n//# sourceURL=webpack://mathsolver/./index.js?");

/***/ }),

/***/ "./src/js/funzione.js":
/*!****************************!*\
  !*** ./src/js/funzione.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Funzione\": () => (/* binding */ Funzione)\n/* harmony export */ });\n/* harmony import */ var _termine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./termine */ \"./src/js/termine.js\");\n\nwindow.Termine = _termine__WEBPACK_IMPORTED_MODULE_0__.Termine;\n\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo Funzione\n * \n * @typedef {Object} FunzioneOptions\n * @property {Array.<Termine>} termini - Termini di cui è composta la funzione\n * @property {Array.<string>} membri - membri di cui è composta la funzione\n * @property {string} parteFissa - parte della funzione che non viene modificata\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Membro di una funzione\n * \n * @typedef {Object} Membro\n * @property {Array.<Termine>} numeratore - Numeratore del membro\n * @property {Array.<string>} denominatore - Numeratore del membro (nel caso in cui non ci sia una funzione fratta è 1)\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Questa classe serve a definire le funzioni interpretate a partire da una stringa.\n * Si trova quindi i membri di ogni equazione e tutti i termini che ne fanno parte.\n * Aggiunge inoltre dei metodi molto utili per lavorare con le funzioni matematiche, come ad esempio l'ordinazione e la ricerca del termine noto.\n * Al posto di una funzione si può interpretare un'equazione allo stesso modo\n * \n * @class Funzione\n * @classdesc Funzione matematica\n * @param {FunzioneOptions|string} options Opzioni per inizializzare una funzione\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Primitiva\n * \n * @typedef {Object} Primitiva\n * @property {Array.<string>} passaggi - Codice HTML con i passaggi per trovare la primitiva\n * @property {Funzione} func - Funzione primitiva come oggetto\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\nfunction Funzione(options) {\n    /**\n     * Termini di cui è composta la funzione\n     * \n     * @name Funzione#termini\n     * @type {Array.<Termine>}\n     * @default []\n     */\n    this.termini = [];\n    /**\n     * Membri di cui è composta la funzione.\n     * Ogni membro è composto da numeratore e denominatore, a loro volta composti da termini\n     * \n     * @name Funzione#membri\n     * @type {Array.<Membro>}\n     * @default []\n     */\n    this.membri = [];\n    this.insiemePositivo = [];\n    this.insiemeNegativo = [];\n    /**\n     * Parte fissa della funzione o dell'equazione, ovvero quella parte che non viene modificata.\n     * Es. y=2x^2+2\n     * La parte fissa è y\n     * \n     * x=33\n     * La parte fissa è x\n     * \n     * Serve per poter stampare la funzione sotto forma di stringa salvandosi la parte che non viene mai modificata.\n     * \n     * @name Funzione#parteFissa\n     * @type {string}\n     * @default y\n     * @example\n     * let funzione = new Funzione('y=2x^2+2');\n     * // Completo la funzione\n     * funzione.completa();\n     * // Stampo la funzione come stringa\n     * console.log(funzione.toString());\n     * // y=2x^2+0x+2\n     */\n    this.parteFissa = 'y';\n\n    switch (typeof (options)) { // In base al tipo di dato delle opzioni che sono state passate\n        case 'FunzioneOptions': // Se ha passato un oggetto di tipo FunzioneOptions\n            // Prendo le opzioni\n            this.termini = options.termini;\n            this.membri = options.membri;\n            this.parteFissa = options.parteFissa;\n            break;\n        case 'string': // Se ha passato una stringa\n            // Intrepreto la stringa e mi prendo i dati necessari\n            Funzione.interpreta(options, this);\n            break;\n        default:\n            throw 'Per favore passa un oggetto di tipo FunzioneOptions oppure una stringa!';\n    }\n\n    /**\n     * Metodo che ritorna il termine noto della funzione.\n     * Va a cercare tra tutti i termini quello che non ha una parte letterale così da poter tornare poi il coefficiente.\n     * \n     * @method\n     * @name Funzione#termineNoto\n     * @returns {number} Termine noto\n     */\n    this.termineNoto = function () {\n        let termine = 0;\n        for (let i = 0; i < this.termini.length; i++) {\n            if (this.termini[i].parteLetterale == null) return this.termini[i].coefficiente;\n        }\n        return termine;\n    }\n\n    /**\n     * Metodo che ritorna il grado della funzione\n     * \n     * @method\n     * @name Funzione#grado\n     * @return {number} Grado della funzione\n     */\n    this.grado = function () {\n        // Cerco tra tutti i termini quello con il grado maggiore\n        return Math.max(...this.termini.map(termine => {\n            if (termine.parteLetterale) {\n                return termine.parteLetterale.esponente;\n            } else {\n                return 0;\n            }\n        }));\n    }\n\n    /**\n     * Metodo che ritorna il termine con un determinato esponente nella parte letterale\n     * \n     * @method\n     * @name Funzione#getByExp\n     * @param {number} exp Esponente che deve avere il termine nella parte letterale\n     * @return {Termine} Termine con quell'esponente\n     */\n    this.getByExp = function (exp) {\n        return this.termini.filter(termine => {\n            if (termine.parteLetterale) {\n                return termine.parteLetterale.esponente == exp;\n            }\n        })[0];\n    }\n\n    /**\n     * Metodo che ordina l'array di termini in modo decrescente in base all'esponente della parte letterale\n     * Non ritorna nulla perché modifica direttamente l'oggetto\n     * \n     * @method\n     * @name Funzione#ordina\n     */\n    this.ordina = function () {\n        // Ordino l'array dei termini in modo decrescente in base all'esponente della parte letterale\n        this.termini.sort((a, b) => (b.parteLetterale ? b.parteLetterale.esponente : 0) - (a.parteLetterale ? a.parteLetterale.esponente : 0));\n    }\n\n    /**\n     * Metodo che completa la funzione aggiungendo gli esponenti mancanti in modo tale che ci sia un termine per ogni esponente a partire dal grado della funzione\n     * Es: x^3+0x^2+x\n     * \n     * @method\n     * @name Funzione#completa\n     */\n    this.completa = function () {\n        const gradoFunzione = this.grado(); // Prendo il grado\n        for (let i = gradoFunzione; i > 0; i--) { // Parto dal grado fino ad esponente 1\n            // Se non c'è un termine con questo esponente\n            if (this.termini.filter(termine => {\n                if (termine.parteLetterale) {\n                    return termine.parteLetterale.esponente == i;\n                }\n            }).length == 0) {\n                // Lo aggiungo\n                this.termini.push(new _termine__WEBPACK_IMPORTED_MODULE_0__.Termine({\n                    coefficiente: 0,\n                    parteLetterale: new ParteLetterale({\n                        lettera: 'x',\n                        esponente: i\n                    })\n                }));\n            }\n        }\n        // Se manca il coefficiente\n        if (this.termini.length < (gradoFunzione + 1)) {\n            // Lo aggiungo\n            this.termini.push(new _termine__WEBPACK_IMPORTED_MODULE_0__.Termine({\n                coefficiente: 0,\n                parteLetterale: new ParteLetterale({\n                    lettera: 'x',\n                    esponente: 0\n                })\n            }));\n        }\n        // Ordino la funzione\n        this.ordina();\n    }\n\n    /**\n     * Metodo che ritorna il coefficiente angolare di una retta.\n     * Se la funzione non è una retta ritorna null\n     * \n     * @method\n     * @name Funzione#coefficienteAngolare\n     */\n    this.coefficienteAngolare = function () {\n        if (this.grado() !== 1) { // Se non è una retta\n            return null;\n        }\n\n        // Prendo il coefficiente del termine di grado 1\n        const coefficiente = this.getByExp(1).coefficiente;\n        let radianti = Math.atan(coefficiente);\n        let gradi = radianti * 180 / Math.PI;\n\n        return {\n            numero: coefficiente,\n            gradi: gradi,\n            radianti: radianti,\n            angoloAcuto: coefficiente > 0,\n            angoloRetto: coefficiente == 0,\n            angoloOttuso: coefficiente < 0\n        }\n    }\n\n    /**\n     * Metodo che trova il dominio della funzione\n     * \n     * @method\n     * @name Funzione#tipologia\n     */\n    this.dominio = function () {\n        // Il dominio di una funzione razionale intera è questo\n        return `(-\\\\infty,+\\\\infty)`;\n    }\n\n    /**\n     * Metodo che trova la tipologia della funzione\n     * \n     * @method\n     * @name Funzione#tipologia\n     */\n    this.tipologia = function () {\n        return 'Funzione razionale intera';\n    }\n\n    /**\n     * Metodo che calcola la primitiva della funzione e la ritorna, con tutti i passaggi\n     * \n     * @method\n     * @name Funzione#primitiva\n     * @returns {Primitiva} Funzione primitiva\n     */\n    this.primitiva = function () {\n        let nuovaFunzione = ``;\n        const passaggi = [];\n\n        // Innanzitutto per ogni termine faccio un nuovo integrale\n        // E nel passaggio ci sarà il coefficiente del termine moltiplicato per l'integrale\n        let primoPassaggio = `F(x)=`;\n        let secondoPassaggio = primoPassaggio;\n\n        this.termini.forEach((termine, i) => {\n            const termLetterale = termine.parteLetterale ? termine.parteLetterale.toString() : `x^0`;\n\n            if (i > 0) {\n                primoPassaggio += ` `;\n                nuovaFunzione += ` `;\n\n                if (termine.coefficiente >= 0) {\n                    primoPassaggio += `+`;\n                    nuovaFunzione += `+`;\n                }\n            }\n\n            let termCoefficiente = termine.coefficiente;\n\n            if (termCoefficiente == 1) {\n                termCoefficiente = '';\n            } else if (termCoefficiente == -1) {\n                termCoefficiente = '-';\n            }\n\n            const nuovoIntegrale = termLetterale ? `\\\\int ${termLetterale.replace('x^0', '')} dx` : ``;\n\n            primoPassaggio += `${termCoefficiente}`;\n            primoPassaggio += nuovoIntegrale;\n\n            const funcDaIntegrare = new Funzione(`y=${termine.coefficiente}${termLetterale}`);\n\n            // Incremento di uno l'esponente\n            funcDaIntegrare.termini[0].parteLetterale.esponente++;\n            funcDaIntegrare.termini[0].coefficiente = termine.coefficiente / funcDaIntegrare.termini[0].parteLetterale.esponente;\n\n            // La nuova funzione avrà quindi come coefficiente il coefficiente attuale fratto il nuovo esponente\n            nuovaFunzione += funcDaIntegrare.toString(false);\n        });\n\n        const func = new Funzione(nuovaFunzione);\n        secondoPassaggio += func.toString(true);\n\n        passaggi.push(primoPassaggio);\n        passaggi.push(secondoPassaggio);\n\n        return { func, passaggi };\n    };\n\n    /**\n     * Metodo che restituisce la derivata della funzione\n     * \n     * @method\n     * @param {number} grado Grado di cui calcolare la derivata\n     * @returns \n     */\n    this.derivata = function(grado = 1) {\n        let func = this.toString();\n\n        for(let i = 0; i < grado;i++) {\n            func = math.derivative(func, 'x').toString().replace(/\\*/g, '').replace(/\\s/g, '');\n        }\n\n        return new Funzione(`y=${func}`);\n    }\n\n    /**\n     * Metodo che controlla se la funzione e' una parabola\n     * \n     * @method\n     * @returns {boolean} Se la funzione e' o no una prabola\n     */\n    this.isParabola = function() {\n        // Una funzione e' una parabola se e' presente la x di secondo grado\n        const term = this.getByExp(2);\n\n        return term && term.coefficiente != 0;\n    }\n\n    /**\n     * Metodo che ritorna la funzione come stringa.\n     * Molto utile nel caso in cui la funzione sia stata modificata da uno dei metodi per poterla stampare a schermo con le modifiche\n     * \n     * @method\n     * @name Funzione#toString\n     * @param {boolean} numeroRazionale Se convertire i numeri in frazioni\n     * @returns {string} Funzione scritta sotto forma di stringa\n     */\n    this.toString = function (numeroRazionale = false) {\n        let string;\n        this.termini.filter(t => t).forEach(termine => {\n            string += termine.toString(numeroRazionale);\n        });\n        // Se il primo carattere è un +  lo rimuovo\n        if (string[0] == '+') string = string.substring(1);\n\n        return string.replace(/undefined/g, '').replace(/Nan/g, '');\n    }\n}\n\n/**\n * Interpreta una funzione scritta come stringa.\n * Serve nel caso in cui si passi una stringa al costruttore e si voglia fare il passaggio di interpretazione in automatico\n * \n * @param {string} funzione Funzione da intepretare\n * @param {Funzione} [obj] Oggetto da modificare\n * @name Funzione#interpreta\n * @static\n * @returns {Funzione} Funzione interpretata\n */\nFunzione.interpreta = function (funzione, obj) {\n    const membri = funzione.split('='); // Prendo i membri separando dall'uguale\n    const parteFissa = funzione.includes('x=') ? 'x' : 'y'; // Prendo la parte fissa della funzione\n\n    funzione = funzione.trim(); // Levo tutti gli spazi\n    funzione = funzione.replace('x=', '').replace('y=', ''); // Lascio solo l'equazione\n    // Splitto per il + o per il - l'espressione in più termini (es. termine con la x^2 ecc...)\n    let partiStringa = MathSolver.splittaEspressione(funzione, ['+', '-']);\n    // Adesso divido ogni termine in parte letterale e numerica\n    const termini = partiStringa.map(string => _termine__WEBPACK_IMPORTED_MODULE_0__.Termine.interpreta(string));\n\n    if (obj) { // Se devo modificare un oggetto\n        obj.membri = membri;\n        obj.parteFissa = parteFissa;\n        obj.termini = termini;\n\n        return obj;\n    } else { // Altrimenti\n        return new Funzione({\n            membri: membri,\n            parteFissa: parteFissa,\n            termini: termini\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack://mathsolver/./src/js/funzione.js?");

/***/ }),

/***/ "./src/js/grafico.js":
/*!***************************!*\
  !*** ./src/js/grafico.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Grafico\": () => (/* binding */ Grafico)\n/* harmony export */ });\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo Grafico\n *\n * @typedef {Object} AsseGraficoOptions\n * @property {number} min=-20 - Valore minimo dell'asse\n * @property {number} max=20 - Valore massimo dell'asse\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Colori che devono avere gli elementi nel grafico\n *\n * @typedef {Object} ColoriGraficoOptions\n * @property {string} assi='#444444' - Colore che devono avere gli assi\n * @property {string} punti='#DD4B44' - Colore che devono avere i punti\n * @property {string} puntiFunzione='4D4DFF' - Colore che devono avere i punti trovati della funzione\n * @property {string} funzione='#484848' - Colore che deve avere la funzione\n * @property {string} testo='#444444'\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Opzioni dell'animazione del grafico\n *\n * @typedef {Object} AnimazioneGraficoOptions\n * @property {boolean} animazione=false - Se utilizzare un'animazione\n * @property {boolean} loop=false - Se l'animazione deve essere in loop\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo Grafico\n *\n * @typedef {Object} GraficoOptions\n * @property {Array.<AsseGraficoOptions>} assi - Opzioni degli assi\n * @property {ColoriGraficoOptions} colori - Colori da avere nel grafico\n * @property {string} font='Poppins' - Font utilizzato nel testo\n * @property {number} focus=3 - Focus della fotocamera\n * @property {AnimazioneGraficoOptions} animazione - Opzioni dell'animazione\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Questa classe serve a gestire la visualizzazione del grafico\n *\n * @class Grafico\n * @classdesc Termine di un'espressione\n * @param {GraficoOptions} options Opzioni per la visualizzazione del grafico\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\nfunction Grafico(options) {\n  if (options == null || options == undefined) options = {};\n\n  // Carico i valori di default\n  options.font = options.font || \"Poppins\";\n  if (options.focus == undefined || options.focus == null) options.focus = 3;\n\n  if (options.colori == undefined || options.colori == null) {\n    options.colori = {\n      assi: \"#444444\",\n      punti: \"#f400a1\",\n      puntiFunzione: \"#4D4DFF\",\n      funzione: \"#484848\",\n      testo: \"#444444\",\n    };\n  } else {\n    if (!options.colori) options.colori = \"#444444\";\n    if (!options.punti) options.punti = \"#DD4B44\";\n    if (!options.puntiFunzione) options.puntiFunzione = \"#4D4DFF\";\n    if (!options.funzione) options.funzione = \"#484848\";\n    if (!options.testo) options.testo = \"#444444\";\n  }\n\n  if (options.assi == undefined || options.assi == null) {\n    options.assi = [\n      {\n        min: -20,\n        max: 20,\n      },\n      {\n        min: -20,\n        max: 20,\n      },\n    ];\n  } else {\n    for (let i = 0; i < options.assi.length; i++) {\n      if (options.assi[i] == undefined || options.assi[i] == null) {\n        options.assi[i] = {\n          min: -20,\n          max: 20,\n        };\n      } else {\n        if (options.assi[i].min == undefined || options.assi[i].min == null)\n          options.assi[i].min = -20;\n        if (options.assi[i].max == undefined || options.assi[i].max == null)\n          options.assi[i].max = 20;\n      }\n    }\n  }\n\n  if (options.animazione == undefined || options.animazione == null) {\n    options.animazione = {\n      animazione: false,\n      loop: false,\n    };\n  } else {\n    if (options.animazione == null || options.animazione == undefined)\n      options.animazione = false;\n    if (options.loop == null || options.loop == undefined) options.loop = false;\n  }\n\n  /**\n   * Valore minimo dell'asse x\n   *\n   * @name Grafico#xMin\n   * @type {number}\n   * @default -20\n   */\n  this.xMin = options.assi[0].min;\n  /**\n   * Valore massimo dell'asse x\n   *\n   * @name Grafico#xMax\n   * @type {number}\n   * @default 20\n   */\n  this.xMax = options.assi[0].max;\n  /**\n   * Valore minimo dell'asse y\n   *\n   * @name Grafico#yMin\n   * @type {number}\n   * @default -20\n   */\n  this.yMin = options.assi[1].min;\n  /**\n   * Valore massimo dell'asse y\n   *\n   * @name Grafico#yMax\n   * @type {number}\n   * @default 20\n   */\n  this.yMax = options.assi[1].max;\n\n  /**\n   * Parametri passati nell'URL\n   *\n   * @name Grafico#_GET\n   * @type {URLSearchParams}\n   * @default 20\n   */\n  this._GET = new URLSearchParams(window.location.search);\n  /**\n   * Funzioni da disegnare nel grafico\n   *\n   * @name Grafico#funzioni\n   * @type {Array.<string>}\n   * @default []\n   */\n  this.funzioni = JSON.parse(this._GET.get(\"funzioni\"));\n\n  /**\n   * punti da disegnare nel grafico\n   *\n   * @name Grafico#punti\n   * @type {Array.<Punto>}\n   * @default []\n   */\n  this.punti = this._GET.get(\"punti\");\n\n  if (this.punti) {\n    // Se ci sono punti\n    this.punti = JSON.parse(this.punti); // Parso l'array\n  }\n\n  let puntiGrafico = [];\n  let funzioniGrafico = null;\n  let assiGrafico = [];\n\n  // Carico il grafico\n  let mathbox = mathBox({\n    plugins: [\"core\", \"controls\", \"cursor\", \"mathbox\", \"fullscreen\"],\n    controls: { klass: THREE.OrbitControls },\n  });\n  if (mathbox.fallback) throw \"WebGL not supported\";\n\n  let three = mathbox.three;\n  three.renderer.setClearColor(new THREE.Color(0xffffff), 1.0);\n\n  let camera = mathbox.camera({\n    proxy: true,\n    position: [0, 0, 3],\n  });\n\n  // Asse cartesione\n  let view = mathbox.cartesian({\n    //range: [[-2, 2], [-1, 1]],\n    range: [\n      [this.xMin, this.xMax],\n      [this.yMin, this.yMax],\n    ],\n    scale: [3, 1.5],\n  });\n\n  // Carico la griglia\n  let griglia = view.grid({\n    width: 1,\n    divideX: 40,\n    divideY: 20,\n    opacity: 0.25,\n  });\n  mathbox.set(\"focus\", options.focus);\n\n  // Carico gli assi\n  let assii = [];\n\n  options.assi.forEach((asse, i) => {\n    assii.push(\n      view.axis({\n        axis: i + 1,\n        width: 3,\n        detail: asse.max * 2,\n        color: options.colori.assi\n      })\n    );\n  });\n\n  const ySplit = \"y=\";\n  const xSplit = \"x=\";\n\n  let funcs = this.funzioni.map((func) => func.trim());\n\n  // Funzioni che iniziano con x=\n  const funzioniDaX = funcs\n    .filter((f) => f.startsWith(xSplit))\n    .map((f) => f.replace(xSplit, \"\"));\n  // Funzioni che iniziano con y=\n  const funzioniDaY = funcs\n    .filter((f) => f.startsWith(ySplit))\n    .map((f) => f.replace(ySplit, \"\"));\n\n  const myEmit = (clb, x, y, func, debug = false) => {\n    if (debug) {\n      console.log(`emit POINT(${x};${y}) for ${func}`);\n    }\n\n    clb(x, y);\n  };\n\n  // Carico tutte le funzioni\n  funzioniGrafico = view.interval({\n    expr: function (emit, x, i, t) {\n      // Per ogni funzione y=\n      // Mi trovo i punti\n      funzioniDaY.forEach((funzione) => {\n        const y = math.parse(funzione).evaluate({ x });\n\n        myEmit(emit, x, y, `y=${funzione}`);\n      });\n\n      // Per ogni funzione x=\n      // Se la x e' uguale alla funzione\n      funzioniDaX\n        .filter(\n          (funzione) =>\n            parseFloat(funzione).toFixed(1) === parseFloat(x).toFixed(1)\n        )\n        .forEach((funzione) => {\n          const max = options.assi[1].max * 2;\n\n          for (\n            let ordinata = options.assi[1].min * 2;\n            ordinata <= max;\n            ordinata++\n          ) {\n            const ascissa = parseFloat(funzione);\n\n            myEmit(emit, ascissa, ordinata, `x=${funzione}`);\n          }\n        });\n    },\n    // Numero di x per cui trovare la y\n    width: 64,\n    // 2 = 2D, 3 = 3D, 4 = 4D\n    channels: 2,\n    items: funcs.length,\n  });\n\n  let curve = view.line({\n    width: 4,\n    color: options.colori.funzione,\n  });\n\n  let points = view.point({\n    size: 5,\n    color: options.colori.puntiFunzione,\n  });\n\n  let ticks = view.ticks({\n    width: 5,\n    size: 15,\n    color: options.colori.testo,\n  });\n\n  /*let format =\n        view.format({\n            digits: 2,\n            weight: 'bold',\n        });\n\n    let labels =\n        view.label({\n            color: options.colori.testo,\n            zIndex: 1,\n        });*/\n\n  options.assi.forEach((asse, i) => {\n    const nomi = [\"x\", \"y\"];\n    const offset = [\n      [25, 0],\n      [0, 25],\n    ];\n    const offsetTicks = [\n      [0, 40],\n      [40, 0],\n    ];\n    const coordinate = [\n      [this.xMax, 0],\n      [0, this.yMax],\n    ];\n\n    const scala = view.scale({\n      axis: i + 1,\n      divide: asse.max / 2,\n      nice: true,\n      zero: i == 0,\n    });\n    const ticks = view.ticks({\n      width: 5,\n      size: 15,\n      color: options.colori.testo,\n      zBias: 2,\n    });\n    const ticksLabel = view.label({\n      color: options.colori.testo,\n      zIndex: 1,\n      offset: offsetTicks[i],\n      points: scala,\n      text: view.format({\n        digits: 2,\n        font: options.font,\n        weight: \"bold\",\n        style: \"normal\",\n        source: scala,\n      }),\n    });\n    const label = view.label({\n      text: view.text({\n        width: 1,\n        data: [nomi[i]],\n        font: options.font,\n        weight: \"bold\",\n        style: \"normal\",\n      }),\n      points: view.array({\n        width: 1,\n        channels: 2,\n        data: [coordinate[i]],\n      }),\n      size: 16,\n      color: options.colori.testo,\n      outline: 0,\n      background: \"transparent\",\n      offset: offset[i],\n      zIndex: 1,\n    });\n\n    assiGrafico.push({\n      asse: assii[i],\n      scala: scala,\n      ticks: ticks,\n      ticksLabel: ticksLabel,\n      label: label,\n    });\n  });\n\n  if (this.punti) {\n    // Se ci sono punti\n    // Li aggiungo nel grafico\n    this.punti.forEach((punto) => {\n      puntiGrafico.push(\n        view.label({\n          text: view.text({\n            width: 1,\n            data: [punto.nome],\n            font: options.font,\n            weight: \"bold\",\n            style: \"normal\",\n          }),\n          points: view.array({\n            width: 1,\n            channels: 2,\n            data: [[punto.x, punto.y]],\n          }),\n          size: 30,\n          color: punto.foreground ? punto.foreground : options.colori.punti, // Se questo punto ha un colore di testo uso quello\n          outline: 1,\n          background: punto.background ? punto.background : \"transparent\", // Se questo punto ha un colore di sfondo uso quello\n          offset: [10, 10],\n          zIndex: 1,\n        })\n      );\n    });\n  }\n\n  // Animazione\n  if (options.animazione.animazione) {\n    // Se devo avere un'animazione\n    mathbox.play({\n      target: \"cartesian\",\n      pace: 5,\n      to: 2,\n      loop: options.animazione.loop,\n      script: [\n        {\n          props: {\n            range: [\n              [-2, 2],\n              [-1, 1],\n            ],\n          },\n        },\n        {\n          props: {\n            range: [\n              [-4, 4],\n              [-2, 2],\n            ],\n          },\n        },\n        {\n          props: {\n            range: [\n              [-2, 2],\n              [-1, 1],\n            ],\n          },\n        },\n      ],\n    });\n  }\n}\n\n\n\n\n//# sourceURL=webpack://mathsolver/./src/js/grafico.js?");

/***/ }),

/***/ "./src/js/mathsolver.js":
/*!******************************!*\
  !*** ./src/js/mathsolver.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MathSolver\": () => (/* binding */ MathSolver)\n/* harmony export */ });\n/* harmony import */ var _funzione__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./funzione */ \"./src/js/funzione.js\");\n\nwindow.Funzione = _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione;\n\nString.prototype.isAlpha = function () {\n  return this.match(\"^[a-zA-Z()]+$\");\n};\n\n/**\n * Punto da visualizzare nel grafico\n *\n * @typedef {Object} Punto\n * @property {string} x - Ascissa del punto\n * @property {string} y - Ordinata punto\n * @property {string} nome - Nome del punto (opzionale)\n * @property {string} background - Colore di sfondo del punto (opzionale)\n * @property {string} foreground - Colore di testo del punto (opzionale)\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Risultato di una scomposizione\n *\n * @typedef {Object} RisultatoScomposizione\n * @property {string} equazioneScomposta - Equazione scomposta, come stringa\n * @property {string} scomposizione - Codice HTML da inserire dentro un elemento per visualizzare i passaggi della scomposizione\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Opzioni per il disegno del grafico con MathSolver\n *\n * @typedef {Object} MathSolverGraficoOptions\n * @property {HTMLElement} elemento - Elemento del frame dove viene visualizzato il grafico\n * @property {string} pagina - Pagina html dove viene visualizzato il grafico, da inserire all'interno del frame\n * @property {boolean} punti - Se aggiungere i punti nel grafico o no\n * @property {boolean} asintoti - Se visualizzare anche gli asintoti nel grafico\n * @property {boolean} direttrice - Se visualizzare anche la direttrice nel grafico (solamente nella parabola)\n * @property {boolean} asse - Se visualizzare anche l'asse nel grafico (solamente nella parabola)\n * @property {boolean} vertice - Se visualizzare anche il vertice nel grafico (solamente nella parabola)\n * @property {boolean} fuoco - Se visualizzare anche il fuoco nel grafico (solamente nella parabola)\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Opzioni per il disegno del grafico con MathSolver\n *\n * @typedef {Object} MathSolverElementiOptions\n * @property {HTMLElement} listaPunti - Lista non ordinata dove inserire i punti\n * @property {HTMLElement} passaggiScomposizione - Elemento dove vengono visualizzati i passaggi della scomposizione    (es. '#scomposizione')\n * @property {HTMLElement} equazioniRisolte - Elemento dove vengono visualizzata la risoluzione di equazioni per risolverne una di grado maggiore   (es. '#equazioni-risolte')\n * @property {HTMLElement} risultato - Elemento dove viene visualizzato il risultato\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo MathSolver.\n * Prende tutte le opzioni necessarie per disegnare le funzioni ecc...\n *\n * @typedef {Object} MathSolverOptions\n * @property {MathSolverGraficoOptions} grafico - Opzioni del grafico\n * @property {MathSolverElementiOptions} elementi - Elementi dove inserire i valori\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Libreria che permette di eseguire diverse operazioni matematiche, come la risoluzione di equazioni e l'intersezione con gli assi\n *\n * @class MathSolver\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @param {MathSolverOptions} options Opzioni per inizializzare MathSolver\n * @version 1.0\n */\nfunction MathSolver(options) {\n  /**\n   * Lettera attualemente scelta e stampata a schermo\n   *\n   * @name MathSolver#letteraAttuale\n   * @type {string}\n   */\n  this.letteraAttuale;\n  /**\n   * Elenco completo dei punti visualizzati sullo schermo\n   *\n   * @name MathSolver#puntiAttivi\n   * @type {Array.<Punto>}\n   */\n  this.puntiAttivi = [];\n\n  /**\n   * Metodo che ritorna i punti attivi per un determinato asse cartesiano\n   *\n   * @method\n   *\n   * @param {string} asse Asse di cui prendere i punti\n   * @returns {Array.<Punto>} Array di punti\n   */\n  this.puntiAsse = function (asse) {\n    switch (asse) {\n      case \"x\":\n        return this.puntiAttivi.filter((punto) => punto.y == 0);\n      case \"y\":\n        return this.puntiAttivi.filter((punto) => punto.x == 0);\n    }\n  };\n\n  /**\n   * Metodo che modifica un punto nello schermo\n   *\n   * @method\n   * @name MathSolver#modificaPunto\n   * @param {string} x Funzioni da disegnare a schermo\n   * @param {string} y Eventuali punti da aggiungere al grafico\n   * @param {string} [nome] Nome del punto\n   * @returns\n   */\n  this.modificaPunto = function (x, y, nome) {\n    const index = this.puntiAttivi.findIndex((p) => p.x === x && p.y === y);\n\n    if (index == null && index == undefined) {\n      // Se non trovo il punto\n      // Mi fermo\n      return;\n    }\n\n    nome = nome || this.puntiAttivi[index].nome;\n\n    const punto = {\n      x,\n      y,\n      nome,\n    };\n\n    this.puntiAttivi[index] = punto;\n\n    return punto;\n  };\n\n  /**\n   * Metodo che aggiunge un punto nello schermo\n   *\n   * @method\n   * @name MathSolver#aggiungiPunto\n   * @param {string} x Funzioni da disegnare a schermo\n   * @param {string} y Eventuali punti da aggiungere al grafico\n   * @param {string} [nome] Nome del punto\n   */\n  this.aggiungiPunto = function (x, y, nome) {\n    if (x === 0 && y === 0) {\n      nome = \"O\";\n    }\n\n    const found = (this.puntiAttivi || []).find(\n      (punto) => punto.x == x && punto.y == y\n    );\n\n    // Se il punto esiste gia' lo ritorno\n    if (found) {\n      return found;\n    }\n\n    // Prendo la lettera successiva per dare il nome al punto\n    // Ovviamente se non e' stato gia' deciso il nome\n    let nomePunto =\n      nome ||\n      (this.letteraAttuale\n        ? String.fromCharCode(\n            this.letteraAttuale.charCodeAt(this.letteraAttuale.length - 1) + 1\n          )\n        : \"A\");\n\n    if (nome) {\n      // Se il punto ha un nome specifico lo metto\n      nomePunto = nome;\n    } else {\n      // Altrimenti lo prendo in ordine alfabetico\n      do {\n        nomePunto = this.letteraAttuale\n          ? String.fromCharCode(\n              this.letteraAttuale.charCodeAt(this.letteraAttuale.length - 1) + 1\n            )\n          : \"A\";\n        this.letteraAttuale = nomePunto; // Mi memorizzo in che lettera siamo arrivati\n      } while (this.puntiAttivi.find((p) => p.nome === nomePunto));\n      // Continuo ad andare avanti se vedo che esiste gia' un punto con questo nome\n    }\n\n    // Se questo punto non esiste già\n    // Lo aggiungo\n    const nuovoPunto = {\n      x,\n      y,\n      nome: nomePunto,\n    };\n    this.puntiAttivi.push(nuovoPunto);\n\n    let code = `${\n      document.querySelector(options.elementi.listaPunti).innerHTML\n    }<li style=\"list-style-type: none;\">`;\n    code += this.toLatex(\n      `${nomePunto}(${MathSolver.numeroRazionale(\n        x\n      )}, ${MathSolver.numeroRazionale(y)})`\n    );\n    code += `</li>`;\n    document.querySelector(options.elementi.listaPunti).innerHTML = code;\n\n    return nuovoPunto;\n  };\n\n  /**\n   * Metodo che svuota la lista dei punti aggiunti\n   *\n   * @method\n   * @name MathSolver#pulisciPunti\n   */\n  this.pulisciPunti = function () {\n    document.querySelector(options.elementi.listaPunti).innerHTML = \"\";\n    this.letteraAttuale = null;\n    this.puntiAttivi.length = 0;\n  };\n\n  /**\n   * Metodo che nasconde il risultato dallo schermo\n   *\n   * @method\n   * @name MathSolver#togliRisultato\n   */\n  this.togliRisultato = function () {\n    console.log(\"bbb\");\n    document.querySelector(options.elementi.risultato).style.display = \"none\";\n    document.querySelector(\n      options.elementi.passaggiScomposizione\n    ).style.display = \"none\";\n    document.querySelector(options.elementi.equazioniRisolte).style.display =\n      \"none\";\n    document.querySelector(options.elementi.passaggiScomposizione).innerHTML =\n      \"\";\n    document.querySelector(options.elementi.equazioniRisolte).innerHTML = \"\";\n    pulisciPunti();\n  };\n\n  /**\n   * Metodo che mostra il risultato nello schermo\n   *\n   * @method\n   * @name MathSolver#mostraRisultato\n   */\n  this.mostraRisultato = function () {\n    document.querySelector(options.elementi.risultato).style.display = \"block\";\n  };\n\n  /**\n   * Questo metodo permette di disegnare una funzione in un grafico richiamando una pagina impostata nelle opzioni di MathSolver.\n   * Prende come parametro solamente la funzione da visualizzare oppure un array di funzioni\n   *\n   * @method\n   * @name MathSolver#disegnaFunzione\n   * @param {string|Array.<string>} funzioni Funzioni da disegnare a schermo\n   * @param {Array.<Punto>} [punti] Eventuali punti da aggiungere al grafico\n   */\n  this.disegnaFunzione = function (funzioni, punti) {\n    try {\n      if (typeof funzioni == \"string\") {\n        // Se è stata passata una sola stringa\n        funzioni = [funzioni]; // Lo trasformo in array\n      }\n\n      let url = new URL(options.grafico.pagina, `https://prova.it/`);\n      url.searchParams.append(\"funzioni\", JSON.stringify(funzioni)); // Aggiungo le funzioni\n      // Se devo aggiungere i punti\n      if (options.grafico.punti && punti) {\n        url.searchParams.append(\"punti\", JSON.stringify(punti)); // Aggiungo i punti\n      }\n      url = url.toString().replace(\"https://prova.it/\", \"\");\n\n      options.grafico.elemento.src = url; // Carico il grafico nella pagina\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  /**\n   * Il codice Latex per essere interpretato correttamente dalla libreria MathJax deve trovarsi in mezzo ai caratteri di apertura e di chiusura.\n   * Per risolvere questo problema è stato creato questo metodo\n   *\n   * @method\n   * @name MathSolver#toLatex\n   * @param {string} string Codice Latex\n   * @param {boolean} [add=true] Se aggiungere le stringhe iniziali e finali\n   *\n   * @returns {string} Stringa di codice in Latex\n   */\n  this.toLatex = function (string, add = true) {\n    if (add) {\n      return `\\\\[${string}\\\\]`;\n    }\n\n    return string;\n  };\n\n  /**\n   * Se il numero passato come argomento è negativo lo mette tra parentesti, altrimenti lo lascia com'è\n   *\n   * @method\n   * @name MathSolver#controllaParentesi\n   * @param {number} numero Numero da controllare\n   *\n   * @returns {string} Numero come stringa e tra parentesi se negativo\n   */\n  this.controllaParentesi = function (numero) {\n    numero = MathSolver.numeroRazionale(numero);\n\n    if (numero < 0) return `(${numero})`;\n\n    return numero.toString();\n  };\n\n  /**\n   * Questo metodo ritorna tutti i divisori di un numero, utile per la scomposizione con Ruffini\n   *\n   * @method\n   * @name MathSolver#trovaDivisori\n   * @param {number} n Numero di cui trovare i divisori\n   * @param {boolean} [negativi=true] Prendere anche valori negativi\n   */\n  this.trovaDivisori = function (n, negativi = true) {\n    n = Math.abs(n); // Faccio il valore assoluto del numero\n\n    let divisori = [];\n\n    for (let i = 1; i <= parseInt(Math.sqrt(n)); i++) {\n      if (n % i == 0) {\n        if (parseInt(n / i) == i) {\n          divisori.push(i);\n        } else {\n          divisori.push(i);\n          divisori.push(parseInt(n / i));\n        }\n      }\n    }\n\n    // Se devo aggiungere anche i numeri negativi\n    if (negativi) {\n      // Li aggiungo\n      divisori = divisori.concat(divisori.map((divisore) => -divisore));\n    }\n\n    // Ordino l'array\n    divisori.sort((a, b) => a - b);\n\n    return divisori;\n  };\n\n  /**\n   * Metodo che controlla se un numero è uno zero del polinomio (ovvero che lo annulla)\n   *\n   * @method\n   * @name MathSolver#isZeroPolinomio\n   * @param {number} numero\n   * @param {string} polinomio\n   */\n  this.isZeroPolinomio = function (numero, polinomio) {\n    return (\n      math.parse(polinomio).evaluate({\n        x: numero,\n      }) == 0\n    );\n  };\n\n  /**\n   * Questo metodo scompone un'equazione utilizzando il metodo di Ruffini.\n   * Oltre a tornare il risultato visualizza a schermo i passaggi negli elementi passati nelle opzioni\n   *\n   * @method\n   * @name MathSolver#scomponiConRuffini\n   * @param {Funzione} funzione Funzione da scomporre con ruffini\n   * @returns {RisultatoScomposizione} risultato della scomposizione\n   */\n  this.scomponiConRuffini = function (funzione) {\n    let equazioneScomposta = [];\n    let scomposizione = ``;\n\n    funzione.ordina(); // Ordino la funzione in modo decrescente in base all'esponente della parte letterale\n    const polinomio = funzione.membri[0];\n    const termineNoto = funzione.termineNoto();\n    let zeroPolinomio;\n    let divisoriTermineNoto = [];\n    let divisoriICoefficiente = [];\n    let probabiliZero = [termineNoto];\n\n    if (termineNoto !== 0) {\n      // Se c'è il termine noto\n      // Cerco i divisori del termine noto\n      divisoriTermineNoto = this.trovaDivisori(funzione.termineNoto());\n    }\n\n    /*\n        I probabili sono:\n        - Termine noto\n        - Divisori del termine noto\n        - Primo coefficiente\n        - Divisori del I coefficiente (con segno +)\n        - Rapporti tra divisori del termine noto e divisori del I coefficiente\n        */\n    // Aggiungo i divisori del termine noto\n    probabiliZero = probabiliZero.concat(divisoriTermineNoto);\n    // Aggiungo il primo coefficiente\n    probabiliZero = probabiliZero.concat(funzione.termini[0].coefficiente);\n    // Aggiungo i divisori del I coefficiente\n    divisoriICoefficiente = this.trovaDivisori(\n      funzione.termini[0].coefficiente,\n      false\n    );\n    probabiliZero = probabiliZero.concat(divisoriICoefficiente);\n    // Aggiungo i rapporti tra i divisori del termine noto e i divisori del I coefficiente\n    // Per ogni divisore del termine noto\n    for (let divisore in divisoriTermineNoto) {\n      // Per ogni divisore del primo coefficiente\n      for (let divisore2 in divisoriICoefficiente) {\n        probabiliZero.push(divisore / divisore2);\n      }\n    }\n\n    // Tra i probabili zero del polinomio, cerco quello giusto\n    for (let divisore of probabiliZero) {\n      if (this.isZeroPolinomio(divisore, polinomio)) {\n        // Se il divisore è lo zero del polinomio\n        zeroPolinomio = divisore;\n        break;\n      }\n    }\n\n    // Se lo zero del polinomio esiste\n    if (zeroPolinomio !== undefined && zeroPolinomio !== null) {\n      // Completo il polinomio con i termini mancanti\n      funzione.completa();\n      let moltiplicazioni = ``;\n      let somme = ``;\n      let risultati = [];\n\n      let risultato = funzione.termini[0].coefficiente * zeroPolinomio; // Moltiplico il primo coefficiente per lo zero del polinomio\n      for (let i = 1; i < funzione.termini.length; i++) {\n        // A partire dal secondo termine\n        moltiplicazioni += `<td>${this.toLatex(risultato)}</td>`;\n        risultato = funzione.termini[i].coefficiente + risultato;\n        risultati.push(risultato);\n        somme += `<td>${this.toLatex(risultato)}</td>`;\n        risultato = risultato * zeroPolinomio;\n      }\n\n      let griglia = `<table class=\"table tabella-ruffini text-white\">\n    <tbody>\n    <tr>\n        <td></td>`;\n\n      for (let i = 0; i < funzione.termini.length; i++) {\n        griglia += `<td>${this.toLatex(funzione.termini[i].coefficiente)}</td>`;\n      }\n\n      griglia += `</tr>\n        <tr>\n            <td>${this.toLatex(zeroPolinomio)}</td>\n            <td></td>\n            ${moltiplicazioni}\n        </tr>`;\n\n      griglia += `\n        <tr class=\"somme-ruffini\">\n            <td></td>\n            <td>${this.toLatex(funzione.termini[0].coefficiente)}</td>\n            ${somme}`;\n      griglia += `\n        </tr>\n    </tbody>\n</table>`;\n\n      // Dopo aver fatto la griglia ci creiamo più equazioni\n      risultati = [funzione.termini[0].coefficiente].concat(risultati);\n      let exp = funzione.grado() - 1;\n      let scomposta = ``;\n      for (let i = 0; i < risultati.length - 1; i++) {\n        // Per ogni risultato\n        if (risultati[i] !== 0) {\n          // Se il risultato non è zero\n          // Se il risultato è -1\n          if (risultati[i] == -1) {\n            if (exp !== 0) {\n              scomposta += \"-\";\n            } else {\n              scomposta += \"-1\";\n            }\n          } else if (risultati[i] == 1) {\n            // Se è 1\n            // Se non è il primo risultato\n            if (i > 0) {\n              if (exp !== 0) {\n                scomposta += \"+\";\n              } else {\n                scomposta += \"+1\";\n              }\n            }\n          } else {\n            // Altrimenti\n            if (risultati[i] > 0) scomposta += \"+\";\n            scomposta += risultati[i];\n          }\n          if (exp !== 0) {\n            if (exp !== 1) {\n              scomposta += `x^${exp}`;\n            } else {\n              scomposta += `x`;\n            }\n          }\n        }\n        exp--;\n      }\n      equazioneScomposta.push(scomposta);\n\n      // Divido il polinomio per \"x-(x1)\" dove \"x1\" è lo zero del polinomio\n      let controllaMeno = ``;\n      // Se lo zero del polinomio è negativo\n      if (zeroPolinomio < 0) {\n        controllaMeno = `\\\\frac {${polinomio}} {x+${Math.abs(zeroPolinomio)}}`;\n        equazioneScomposta.push(`x+${Math.abs(zeroPolinomio)}`);\n      } else {\n        equazioneScomposta.push(`x-${zeroPolinomio}`);\n      }\n\n      let equazioneScompostaString = ``;\n      equazioneScomposta.forEach((eq) => {\n        equazioneScompostaString += `(${eq})`;\n      });\n\n      scomposizione += `<div class=\"col d-flex justify-content-center\">\n    <div class=\"card bg-primary text-white mb-4\">\n        <div class=\"card-header\">${this.toLatex(\n          \"\\\\text{Scomposizione con Ruffini}\"\n        )}</div>\n        <div class=\"card-body\">\n            ${this.toLatex(\n              \"\\\\frac {\" +\n                polinomio +\n                \"}\" +\n                \" {x-\" +\n                this.controllaParentesi(zeroPolinomio) +\n                \"}\" +\n                (controllaMeno !== \"\" ? \" = \" + controllaMeno : \" \")\n            )}\n        \n            <br>\n            ${griglia}\n            <br>\n            ${this.toLatex(equazioneScompostaString)}\n        </div>\n    </div>\n</div>`;\n    }\n\n    return {\n      equazione: equazioneScomposta,\n      scomposizione: scomposizione,\n    };\n  };\n\n  /**\n   * Questo metodo scompone un'equazione trovando il metodo migliore per scomporla\n   *\n   * @method\n   * @name MathSolver#scomponi\n   * @param {Funzione} funzione Funzione da scomporre\n   */\n  this.scomponi = function (funzione) {\n    return this.scomponiConRuffini(funzione);\n  };\n\n  /**\n   * Questo metodo risolve le equazioni di grado superiore al 2, è stato scritto per dividere la risoluzione di equazioni semplici da queste\n   *\n   * @method\n   * @name MathSolver#risolviEquazioneGradiMaggiori\n   * @param {string} equazione Equazione da risolvere\n   * @param {number} grado Grado dell'equazione da risolvere\n   * @param {string} asse Asse con cui è stata effettuata l'intersezione\n   * @param {boolean} [sistema=true] Se risolvere e basta o fare il sistema\n   * @param {booolean} [pulisci=true] Se pulire i div\n   */\n  this.risolviEquazioneGradiMaggiori = function (\n    equazione,\n    grado,\n    asse,\n    sistema = true,\n    pulisci = true\n  ) {\n    let risultati = [];\n\n    if (pulisci) {\n      document.querySelector(options.elementi.passaggiScomposizione).innerHTML =\n        \"\";\n      document.querySelector(options.elementi.equazioniRisolte).innerHTML = \"\";\n    }\n\n    const scomposta = this.scomponi(new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(equazione));\n    // Se l'equazione è scomponibile stampo a schermo la scomposizione\n    if (scomposta.scomposizione !== \"\") {\n      document.querySelector(\n        options.elementi.passaggiScomposizione\n      ).innerHTML += scomposta.scomposizione;\n    }\n    let equazioneScomposta = ``;\n\n    let code = ``;\n    if (sistema)\n      code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n    code += this.toLatex(equazione);\n    if (sistema)\n      code += `${this.toLatex(asse)}\n</td>`;\n\n    if (scomposta.equazione.length > 0) {\n      // Se l'equazione è stata scomposta\n      // La stampo a schermo\n      risultati = [];\n      let equazioniScomposte = [];\n\n      for (let i = 0; i < scomposta.equazione.length; i++) {\n        // per ogni equazione trovata\n        // La risolvo e mi salvo i risultati\n        equazioneScomposta += `(${scomposta.equazione[i]})`;\n        const equazioneRisolta = this.risolviEquazione(\n          `${scomposta.equazione[i]}=0`,\n          null,\n          asse,\n          false,\n          false\n        );\n        // Mostro a schermo i passaggi per la risoluzione dell'equazione\n        document.querySelector(\n          options.elementi.equazioniRisolte\n        ).innerHTML += `<div class=\"col-md-6\">\n    <div class=\"card bg-primary text-white mb-4\">\n        <div class=\"card-header\">${this.toLatex(\n          \"\\\\text{Risoluzione equazione}\"\n        )}</div>\n        <div class=\"card-body\">\n            ${equazioneRisolta.code}\n        </div>\n    </div>\n</div>`;\n        risultati = risultati.concat(equazioneRisolta.risultati);\n        if (equazioneRisolta.equazioneScomposta) {\n          // Se è presente un'equazione scomposta\n          equazioniScomposte.push(equazioneRisolta.equazioneScomposta);\n        }\n      }\n\n      // VIsualizzo a schermo i passaggi\n      document.querySelector(\n        options.elementi.passaggiScomposizione\n      ).style.display = \"block\";\n      document.querySelector(options.elementi.equazioniRisolte).style.display =\n        \"flex\";\n\n      /*console.log(document.querySelector(options.elementi.passaggiScomposizione));\n            console.log(document.querySelector(options.elementi.equazioniRisolte));*/\n\n      equazioneScomposta += `=0`;\n      // Visualizzo a schermo l'equazione scomposta\n      if (sistema)\n        code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n      code += this.toLatex(`${equazioneScomposta}`);\n      if (sistema)\n        code += `${this.toLatex(asse)}\n</td>`;\n\n      // Visualizzo a schermo le altre scomposizioni\n      if (sistema) {\n        let ultimaDaConcatenare;\n\n        if (scomposta.equazione.length > 0) {\n          // Se l'equazione è stata scomposta\n          ultimaDaConcatenare = `(${\n            scomposta.equazione[scomposta.equazione.length - 1]\n          })`;\n        }\n\n        equazioniScomposte.forEach((eq) => {\n          eq = eq.split(\"=\")[0]; // Prendo il primo membro dell'equazione\n          eq = `${eq}${ultimaDaConcatenare}`; // Concateno\n\n          code += `<td class=\"spazio-sistema\"></td>\n                <td class=\"graffa-sistema\">`;\n          code += this.toLatex(`${eq}=0`);\n          code += `${this.toLatex(asse)}\n                </td>`;\n\n          ultimaDaConcatenare = eq;\n        });\n      }\n\n      // Rimuovo i doppioni dai risultati\n      risultati = [...new Set(risultati)];\n\n      // Ordino l'array di risultati\n      risultati.sort((a, b) => a - b);\n\n      risultati.forEach((risultato, i) => {\n        if (sistema)\n          code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n        code += this.toLatex(\n          \"x_{\" + (i + 1) + \"} = \" + MathSolver.numeroRazionale(risultato)\n        );\n        if (sistema) code += this.toLatex(\"y_{\" + (i + 1) + \"} = 0\");\n        if (sistema)\n          code += `\n</td>`;\n      });\n    } else {\n      // Altrimenti\n      if (sistema) {\n        code += `<td class=\"spazio-sistema\"></td>\n            <td>${this.toLatex(\n              \"\\\\text{Impossibile scomporre l'equazione}\"\n            )}</td>`;\n      } else {\n        code += this.toLatex(\"\\\\text{Impossibile scomporre l'equazione}\");\n      }\n    }\n\n    return {\n      code: code,\n      risultati: risultati,\n      equazioneScomposta: equazioneScomposta,\n    };\n  };\n\n  /**\n   * Risolve un'equazione di qualunque grado.\n   * Quando un'equazione è di grado superiore al secondo chiama un'altra funzione che la risolve in un altro modo\n   *\n   * @method\n   * @name MathSolver#controllaParentesi\n   * @param {string} equazione Equazione da risolvere\n   * @param {number} grado Grado dell'equazione\n   * @param {string} asse Asse con cui è stata fatta l'intersezione\n   * @param {boolean} [sistema=true] Se risolvere e basta o fare il sistema\n   * @param {boolean} [pulisci=true] Se pulire i div\n   * @returns {*} Risultati dell'equazione e il codice da stampare a schermo\n   */\n  this.risolviEquazione = function (\n    equazione,\n    grado,\n    asse,\n    sistema = true,\n    pulisci = true,\n    aggiungiPunto = true\n  ) {\n    // Prendiamo le informazioni di questa equazione\n    let delta;\n    let espressione = new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(equazione.split(\"=\")[0]);\n    let code = ``;\n    let risultati = [];\n\n    grado = grado || espressione.grado();\n\n    const a = espressione.getByExp(grado);\n    const b = espressione.getByExp(grado - 1);\n\n    switch (grado) {\n      case 1:\n        if (pulisci) {\n          document.querySelector(\n            options.elementi.passaggiScomposizione\n          ).style.display = \"none\";\n          document.querySelector(\n            options.elementi.equazioniRisolte\n          ).style.display = \"none\";\n        }\n\n        if (sistema)\n          code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n        code += this.toLatex(equazione);\n        if (sistema)\n          code += `${this.toLatex(asse)}\n</td>`;\n\n        const termineNoto = espressione.termineNoto();\n\n        if (termineNoto !== 0) {\n          // Se il termine noto è 0\n          // Sposto il termine noto al secondo membro\n          if (sistema)\n            code += `<td class=\"spazio-sistema\"></td>\n              <td class=\"graffa-sistema\">`;\n          code += this.toLatex(\n            espressione.termini[0].toStringWithoutPlus() +\n              \" = \" +\n              MathSolver.numeroRazionale(-termineNoto)\n          );\n          if (sistema)\n            code += `${this.toLatex(asse)}\n              </td>`;\n\n          // Divido il secondo membro per il coefficiente della x\n          // Se il coefficiente è diverso da 1\n          let ascissa = MathSolver.numeroRazionale(\n            Math.round(\n              (-termineNoto / espressione.termini[0].coefficiente) * 100,\n              2\n            ) / 100\n          );\n          let ordinata = asse.split(\"=\")[1];\n\n          if (espressione.termini[0].coefficiente !== 1) {\n            if (sistema)\n              code += `<td class=\"spazio-sistema\"></td>\n                  <td class=\"graffa-sistema\">`;\n            code += this.toLatex(\"x = \" + ascissa);\n            if (sistema)\n              code += `${this.toLatex(asse)}\n                  </td>`;\n          }\n\n          if (aggiungiPunto) {\n            this.aggiungiPunto(ascissa, ordinata);\n          }\n\n          risultati = [ascissa];\n        } else {\n          // Altrimenti\n          if (sistema)\n            code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n          code += this.toLatex(\"x = 0\");\n          if (sistema)\n            code += `${this.toLatex(asse)}\n</td>`;\n          this.aggiungiPunto(0, 0);\n        }\n        break;\n      case 2:\n        if (pulisci) {\n          document.querySelector(\n            options.elementi.passaggiScomposizione\n          ).style.display = \"none\";\n          document.querySelector(\n            options.elementi.equazioniRisolte\n          ).style.display = \"none\";\n        }\n\n        if (sistema)\n          code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n        code += this.toLatex(equazione);\n        if (sistema)\n          code += `${this.toLatex(asse)}\n</td>`;\n\n        const c = espressione.termineNoto();\n        delta = Math.pow(b ? b.coefficiente : 0, 2) - 4 * a.coefficiente * c;\n        const radice = Math.sqrt(delta);\n        const menoCoefficienteB = -(b ? b.coefficiente : 0);\n        const coefficienteA = a ? a.coefficiente : 0;\n\n        risultati = [\n          (menoCoefficienteB - radice) / (2 * coefficienteA),\n          (menoCoefficienteB + radice) / (2 * coefficienteA),\n        ];\n\n        const coefficienteB = b ? b.coefficiente : 0;\n        const menoB = coefficienteB\n          ? `-${this.controllaParentesi(coefficienteB)}`\n          : \"\";\n        const bQuadro = coefficienteB\n          ? `${this.controllaParentesi(coefficienteB)}^2`\n          : \"\";\n\n        // Stampo la formula\n        if (sistema)\n          code += `<td class=\"spazio-sistema\"></td>\n              <td class=\"graffa-sistema\">`;\n        code += this.toLatex(`x_{1,2} = \\\\frac{-b \\\\pm \\\\sqrt{b^2-4ac}} {2a}`);\n\n        if (sistema)\n          code += `${this.toLatex(asse)}\n              </td>`;\n        // Stampo l'equazione con i numeri sostituiti\n        if (sistema)\n          code += `<td class=\"spazio-sistema\"></td>\n              <td class=\"graffa-sistema\">`;\n        code += this.toLatex(\n          `x_{1,2} = \\\\frac{${menoB} \\\\pm \\\\sqrt{${bQuadro}-4*${this.controllaParentesi(\n            a.coefficiente\n          )}*${this.controllaParentesi(c)}}} {${this.controllaParentesi(\n            a.coefficiente * 2\n          )}} = 0`\n        );\n\n        if (sistema)\n          code += `${this.toLatex(asse)}\n              </td>`;\n        // Stampo l'equazione con il delta trovato\n        if (sistema)\n          code += `<td class=\"spazio-sistema\"></td>\n              <td class=\"graffa-sistema\">`;\n\n        code += this.toLatex(\n          `x_{1,2} = \\\\frac{${menoB} \\\\pm \\\\sqrt{${MathSolver.numeroRazionale(\n            delta\n          )}}} {${this.controllaParentesi(a.coefficiente * 2)}}`\n        );\n\n        if (sistema)\n          code += `${this.toLatex(asse)}\n              </td>`;\n        if (delta < 0) {\n          // Se il delta è minore di zero\n          // L'equazione è impossibile\n          // Stampo l'equazione con la radice risolta\n          if (sistema)\n            code += `<td class=\"spazio-sistema\"></td>\n          \n          <td class=\"graffa-sistema\">`;\n          code += this.toLatex(\"\\\\text{eq. imp. in } \\\\mathbb{R}\");\n\n          if (sistema)\n            code += `${this.toLatex(asse)}\n          </td>`;\n        } else {\n          // Altrimenti\n          // Stampo l'equazione con la radice risolta\n          if (sistema)\n            code += `<td class=\"spazio-sistema\"></td>\n          \n          <td class=\"graffa-sistema\">`;\n          code += this.toLatex(\n            `x_{1,2} = \\\\frac{${menoB} \\\\pm ${MathSolver.numeroRazionale(\n              radice\n            )}} {${this.controllaParentesi(a.coefficiente * 2)}}`\n          );\n          if (sistema)\n            code += `${this.toLatex(asse)}\n          </td>`;\n\n          // Se il delta è uguale a zero\n          if (delta == 0) {\n            // Stampo il risultato\n            if (sistema)\n              code += `<td class=\"spazio-sistema\"></td>\n          \n          <td class=\"graffa-sistema\">`;\n            code += this.toLatex(\n              \"x_{1,2} = \\\\pm\" +\n                MathSolver.numeroRazionale(Math.abs(risultati[0]))\n            );\n\n            if (sistema)\n              code += `${this.toLatex(asse)}\n          </td>`;\n            if (aggiungiPunto) {\n              this.aggiungiPunto(risultati[0], 0);\n            }\n          } else {\n            // Stampo i risultati\n            for (let i = 0; i < 2; i++) {\n              if (sistema)\n                code += `<td class=\"spazio-sistema\"></td>\n                      \n                      <td class=\"graffa-sistema\">`;\n              code += this.toLatex(\n                \"x_{\" +\n                  (i + 1) +\n                  \"} = \" +\n                  MathSolver.numeroRazionale(risultati[i])\n              );\n              if (sistema) code += this.toLatex(\"y_{\" + (i + 1) + \"} = 0\");\n              if (sistema) code += `</td>`;\n\n              if (aggiungiPunto) {\n                this.aggiungiPunto(risultati[i], 0);\n              }\n            }\n          }\n        }\n        break;\n      default:\n        return this.risolviEquazioneGradiMaggiori(\n          equazione,\n          grado,\n          asse,\n          sistema,\n          pulisci\n        );\n    }\n\n    return {\n      code: code,\n      risultati: risultati,\n      a: a ? a.coefficiente : 0,\n      b: b ? b.coefficiente : 0,\n      delta,\n    };\n  };\n\n  /**\n   * Effettua l'intersezione di una funzione con un determinato asse\n   *\n   * @method\n   * @name MathSolver#intersezioneAsse\n   * @param {string} funzione Funzione presa in input\n   * @param {string} asse Asse con cui la funzione deve fare l'intersezione\n   */\n  this.intersezioneAsse = function (funzione, asse) {\n    const equazioniAssi = {\n      x: \"y = 0\",\n      y: \"x = 0\",\n    };\n\n    let code = `<h5>${this.toLatex(\n      \"\\\\text{Intersezione con l'asse \" + asse + \"}\"\n    )}</h5>\n<table tborder=0>\n    <tbody>\n        <tr>\n            \n            <td class=\"graffa-sistema\">\n                ${this.toLatex(funzione)}\n                \n                ${this.toLatex(equazioniAssi[asse])}\n            </td>`;\n\n    funzione = new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(funzione); // Interpretiamo la funzione in un oggetto\n\n    if (asse == \"y\") {\n      // Se devo fare l'intersezione con l'asse y\n      const termineNoto = funzione.termineNoto();\n      code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">\n    ${this.toLatex(\"y = \" + MathSolver.numeroRazionale(termineNoto))}\n    ${this.toLatex(equazioniAssi[asse])}\n</td>`;\n      this.aggiungiPunto(0, termineNoto);\n    } else {\n      code += this.risolviEquazione(\n        `${funzione.membri[1]}=0`,\n        funzione.grado(),\n        equazioniAssi[asse]\n      ).code;\n    }\n\n    code += `\n        </tr>\n    </tbody>\n<table>`;\n    return code;\n  };\n\n  /**\n   * Metodo che data una funzione dice se e' pari o dispari\n   *\n   * @method\n   * @param {Funzione} funzione Funzione di cui calcolare se e' pari o ispari\n   * @name Funzione#funzionePariODispari\n   */\n  this.funzionePariODispari = function (funzione) {\n    let code = ``;\n\n    let funzioneString = funzione.membri[1];\n    // Se il primo carattere è un +  lo rimuovo\n    if (funzioneString[0] == \"+\") funzioneString = funzioneString.substring(1);\n\n    // -f(x)\n    let menoFDiX = new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(`y=${funzioneString}`);\n    // Moltiplico tutti i termini per -1\n    menoFDiX.termini.forEach((termine) => {\n      termine.coefficiente = termine.coefficiente * -1;\n    });\n    menoFDiX = menoFDiX.toString(false).replace(\"y=\", \"\");\n    // Se il primo carattere è un +  lo rimuovo\n    if (menoFDiX[0] == \"+\") menoFDiX = menoFDiX.substring(1);\n\n    // f(-x)\n    let fDiMenoX = new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(`y=${funzioneString}`);\n    // Moltiplico per -1 tutti i termini dove l'esponente della parte letterale e' dispari\n    fDiMenoX.termini\n      .filter(\n        (termine) =>\n          termine.parteLetterale && termine.parteLetterale.esponente % 2 === 1\n      )\n      .forEach((termine) => {\n        termine.coefficiente = termine.coefficiente * -1;\n      });\n    fDiMenoX = fDiMenoX.toString(false).replace(\"y=\", \"\");\n    // Se il primo carattere è un +  lo rimuovo\n    if (fDiMenoX[0] == \"+\") fDiMenoX = fDiMenoX.substring(1);\n\n    let menoFDiXCalc = this.toLatex(`-f(x) = -(${funzioneString})`);\n    menoFDiXCalc += this.toLatex(`-f(x) = ${menoFDiX}`);\n    let fDiMenoXCalc = this.toLatex(\n      `f(-x) = ${funzioneString.replace(/x/g, \"(-x)\")}`\n    );\n    fDiMenoXCalc += this.toLatex(`f(-x) = ${fDiMenoX}`);\n\n    code += fDiMenoXCalc;\n    code += `<hr>`;\n    code += menoFDiXCalc;\n    code += `<hr>`;\n\n    const pari = fDiMenoX === funzioneString;\n    const dispari = fDiMenoX === menoFDiX;\n\n    if (pari) {\n      code += this.toLatex(`\\\\text{La funzione è pari}`);\n      code += this.toLatex(`\\\\text{f(-x)=f(x)}`);\n      code += this.toLatex(`${fDiMenoX} = ${funzioneString}`);\n    } else {\n      code += this.toLatex(`\\\\text{La funzione non è pari}`);\n      code += this.toLatex(`f(-x) \\\\neq f(x)`);\n      code += this.toLatex(`${fDiMenoX} \\\\neq ${funzioneString}`);\n    }\n\n    if (dispari) {\n      code += this.toLatex(`\\\\text{La funzione è dispari}`);\n      code += this.toLatex(`\\\\text{f(-x)=-f(x)}`);\n      code += this.toLatex(`${fDiMenoX} = ${menoFDiX}`);\n    } else {\n      code += this.toLatex(`\\\\text{La funzione non è dispari}`);\n      code += this.toLatex(`f(-x) \\\\neq -f(x)`);\n      code += this.toLatex(`${fDiMenoX} \\\\neq ${menoFDiX}`);\n    }\n\n    if (!pari && !dispari) {\n      code += this.toLatex(`\\\\text{La funzione non è né pari né dispari}`);\n    }\n\n    return code;\n  };\n\n  /**\n   * Metodo che converte un insieme da array a stringa in linguaggio latex\n   *\n   * @method\n   * @param {Array<any>} insieme Insieme matematico da convertire in stringa\n   * @returns\n   */\n  this.insiemeToString = function (insieme) {\n    if (insieme.length == 0) {\n      return `\\\\emptyset`;\n    }\n\n    return insieme\n      .map((el) => {\n        let intervallo = ``;\n\n        if (Array.isArray(el)) {\n          intervallo = el\n            .filter((a) => a)\n            .map((a) =>\n              MathSolver.numeroRazionale(\n                a\n                  .toString()\n                  .replace(\"-Infinity\", \"-\\\\infty\")\n                  .replace(\"Infinity\", \"+\\\\infty\")\n              )\n            )\n            .join(\";\");\n        }\n\n        return `(${intervallo})`;\n      })\n      .join(\"\\\\cup\");\n  };\n\n  /**\n   * Metodo che risolve le disequazioni\n   *\n   * @method\n   * @param {Array<string>} disequazioni Disequazioni da risolvere\n   * @param {string} segnoPositivo Segno da utilizzare quando il valore e' positivo alla fine\n   * @param {string} segnoNegativo Segno da utilizzare quando il valore e' negativo alla fine\n   * @returns\n   */\n  this.risolviDisequazioni = function (\n    disequazioni,\n    segnoPositivo = \"+\",\n    segnoNegativo = \"-\"\n  ) {\n    let insiemePositivo = [];\n    let insiemeNegativo = [];\n    let insiemiInOrdine = [];\n    let code = ``;\n\n    // Prendo i numeri presenti nelle disequazioni\n    let numeriDisequazioni = [];\n\n    disequazioni\n      .filter((d) => d.includes(\"x\"))\n      .forEach((d) => {\n        // Separo per il simbolo maggiore o minore per ogni disequazione\n        d.split(/&&|OR/)\n          .map((dd) => dd.replace(/\\s/g, \"\"))\n          .forEach((dd) => {\n            const split = dd.split(/>|</);\n\n            // Prendo solamente il numero utilizzato\n            // Che sara' sempre il secondo elemento dell'array\n            numeriDisequazioni.push(split[1]);\n          });\n      });\n\n    numeriDisequazioni.sort((a, b) => a - b);\n\n    // Costruisco una tabella\n    code += `<div class=\"table-responsive\">\n          <table class=\"table tabella-disequazione\">\n            <thead>\n              <tr class=\"d-flex\">\n              <th scope=\"col\" class=\"th-lg\"></th>\n              ${numeriDisequazioni\n                .filter((n) => n)\n                .map(\n                  (n) =>\n                    '<th scope=\"col\" class=\"th-lg th-numero\">' +\n                    this.toLatex(MathSolver.numeroRazionale(n)) +\n                    \"</th>\"\n                )\n                .join(\"\")}\n              <th scope=\"col\" class=\"th-lg\"></th>\n              </tr>\n            </thead>\n            <tbody>`;\n\n    const cellaRiga = (\n      cella,\n      borderLeft = true,\n      circle = false,\n      mostraSegno = true,\n      borderBottom = true\n    ) => {\n      const segno = cella\n        ? circle\n          ? segnoPositivo\n          : \"+\"\n        : circle\n        ? segnoNegativo\n        : \"-\";\n\n      code += `               <td`;\n\n      if (!circle && borderBottom) {\n        code += ` style=\"border-bottom: 2px ${\n          cella ? \"solid\" : \"dotted\"\n        } #000;\"`;\n      }\n\n      if (borderLeft) {\n        code += ` class=\"td-border-left\"`;\n      }\n\n      // ${!cella ? 'background-color: #f2f2f2 !important;' : ''}\n\n      code += `>${\n        circle\n          ? '<span class=\"circle circle-' +\n            (cella ? \"positive\" : \"negative\") +\n            '\">'\n          : \"\"\n      }${mostraSegno ? (circle ? segno : this.toLatex(segno)) : \"\"}${\n        circle ? \"</span>\" : \"\"\n      }</td>`;\n    };\n\n    numeriDisequazioni = [Number.NEGATIVE_INFINITY, ...numeriDisequazioni];\n\n    // Righe della tabella, col + e il - per ogni riga\n    // Validando la disequazione presente\n    const righe = [];\n\n    disequazioni\n      .filter((d) => d.includes(\"x\"))\n      .forEach((condition) => {\n        // Aggiungo le condizioni per ogni numero\n        righe.push(\n          numeriDisequazioni.map((n) => {\n            let newCondition = condition\n              .replace(/x/g, `${n}`)\n              .replace(/OR/g, ` || `);\n\n            if (newCondition.includes(\">\")) {\n              newCondition = `${newCondition} || ${newCondition.replace(\n                \">\",\n                \"===\"\n              )}`;\n            }\n\n            return eval(newCondition);\n          })\n        );\n      });\n\n    // Aggiungo le righe per ogni disequazione senza incognita\n    disequazioni\n      .filter((d) => !d.includes(\"x\"))\n      .forEach((d) => {\n        let value;\n\n        if (d === \"ALL_VALUES\") {\n          value = true;\n        } else if (d === \"NO_VALUES\") {\n          value = false;\n        } else {\n          value = eval(d);\n        }\n\n        righe.push(numeriDisequazioni.map((_) => value));\n      });\n\n    righe.forEach((riga) => {\n      code += `             <tr class=\"d-flex\">`;\n\n      riga.forEach((a, i) => cellaRiga(a, i > 0));\n\n      code += `             </tr>`;\n    });\n\n    code += `<tr class=\"d-flex\"></tr>`;\n\n    // Costruisco l'ultima riga effettuando le operazioni per ogni colonna\n    const ultimaRiga = [];\n\n    // Per ogni colonna\n    for (let i = 0; i < numeriDisequazioni.length; i++) {\n      // Effettuo le operazioni\n      let res = 1;\n\n      // Per ogni cella presente in quella colonna\n      for (let j = 0; j < righe.length; j++) {\n        res = res * (righe[j][i] ? 1 : -1);\n      }\n\n      ultimaRiga.push(res > 0);\n    }\n\n    code += `             <tr class=\"d-flex\">`;\n    ultimaRiga.forEach((a) => cellaRiga(a, false, true));\n    // cellaRiga(ultimaRiga[ultimaRiga.length - 1], false, false, false, false);\n    code += `             </tr>`;\n\n    code += `            </tbody>\n    </table></div>`;\n\n    // Dall'ultima riga (ovvero quella dei risultati)\n    // costruisco l'insieme positivo e l'insieme negativo\n\n    // Se sono tutti positivi\n\n    // if (ultimaRiga.filter((r) => r).length === ultimaRiga.length) {\n    //   insiemePositivo.push([Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]);\n    //   insiemiInOrdine = [{ positive: insiemePositivo }];\n    // } else if (ultimaRiga.filter((r) => !r).length === ultimaRiga.length) {\n    //   insiemeNegativo.push([Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]);\n    //   insiemiInOrdine = [{ negative: insiemeNegativo }];\n    // } else {\n    let lastIsPositivo;\n    let lastIsNegativo;\n\n    for (let i = 0; i < ultimaRiga.length; i++) {\n      const res = ultimaRiga[i];\n\n      const numero = numeriDisequazioni[i];\n      const numeroSuccessivo = ![null, undefined].includes(\n        numeriDisequazioni[i + 1]\n      )\n        ? numeriDisequazioni[i + 1]\n        : Number.POSITIVE_INFINITY;\n\n      // Se è +\n      if (res) {\n        if (lastIsPositivo) {\n          // Altrimenti\n          // Se il numero precedente era positivo\n          // vado a cambiare il valore finale dell'ultimo intervallo\n          insiemePositivo[insiemePositivo.length - 1][1] = numero;\n          insiemiInOrdine[insiemiInOrdine.length - 1].positive[1] = numero;\n        } else {\n          // Altrimenti l'intervallo è dal numero precedente al numero successivo\n          insiemePositivo.push([numero, numeroSuccessivo]);\n          insiemiInOrdine.push({ positive: [numero, numeroSuccessivo] });\n        }\n\n        // Mi memorizzo che l'ultimo è positivo\n        lastIsPositivo = true;\n        lastIsNegativo = false;\n      } else {\n        if (lastIsNegativo) {\n          // Altrimenti\n          // Se il numero precedente era positivo\n          // vado a cambiare il valore finale dell'ultimo intervallo\n          insiemeNegativo[insiemeNegativo.length - 1][1] = numero;\n          insiemiInOrdine[insiemiInOrdine.length - 1].negative[1] = numero;\n        } else {\n          // Altrimenti l'intervallo è dal numero precedente al numero successivo\n          insiemeNegativo.push([numero, numeroSuccessivo]);\n          insiemiInOrdine.push({ negative: [numero, numeroSuccessivo] });\n        }\n\n        // Mi memorizzo che l'ultimo + negativo\n        lastIsPositivo = false;\n        lastIsNegativo = true;\n      }\n    }\n    // }\n\n    insiemePositivo = insiemePositivo.filter((el) => el.length > 0);\n    insiemeNegativo = insiemeNegativo.filter((el) => el.length > 0);\n    insiemiInOrdine = insiemiInOrdine.filter(\n      (el) => (el.positive || el.negative).length > 0\n    );\n\n    return { code, insiemePositivo, insiemeNegativo, insiemiInOrdine };\n  };\n\n  /**\n   * Metodo che pone una funzione maggiore di zero e risolve la disequazione\n   *\n   * @method\n   * @param {Funzione} funzione Funzione da porre maggiore di zero\n   * @param {string} segnoPositivo Segno da utilizzare quando il valore e' positivo alla fine\n   * @param {string} segnoNegativo Segno da utilizzare quando il valore e' negativo alla fine\n   * @returns\n   */\n  this.funzioneMaggioreDiZero = function (\n    funzione,\n    segnoPositivo = \"+\",\n    segnoNegativo = \"-\"\n  ) {\n    let code = this.toLatex(`${funzione.membri[1]} > 0`);\n\n    // Effettuo la scomposizione portando tutte le parti massimo fino al primo grado\n\n    let partiTemp = [];\n\n    if (funzione.grado() > 1) {\n      const scomp = this.scomponi(new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(`${funzione.membri[1]}=0`));\n      partiTemp = scomp.equazione;\n    }\n\n    let parti = [];\n\n    partiTemp.forEach((parte) => {\n      const func = new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(`${parte}=0`);\n      if (func.grado() == 2) {\n        this.scomponi(func).equazione.forEach((p) => {\n          parti.push(p);\n        });\n      } else {\n        parti.push(parte);\n      }\n    });\n\n    let equazioneScomposta;\n\n    if (parti.length === 0) {\n      if (funzione.grado() > 2) {\n        return {\n          insiemePositivo: [],\n          insiemeNegativo: [],\n          insiemiInOrdine: [],\n          code: this.toLatex(`\\\\text{Impossibile scomporre l'espressione}`),\n        };\n      } else {\n        parti = [`${funzione.membri[1]}`];\n        equazioneScomposta = `${funzione.membri[1]}`;\n      }\n    } else {\n      equazioneScomposta = parti.map((e) => `(${e})`).join(\"\");\n      code += this.toLatex(`${equazioneScomposta} > 0`);\n    }\n\n    code += `<hr>`;\n\n    let disequazioni = [];\n\n    parti.forEach((parte) => {\n      if (parti.length > 1) {\n        code += this.toLatex(`${parte}>0`);\n      }\n\n      const func = new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(`y=${parte}`);\n      func.ordina();\n\n      const grado = func.grado();\n\n      if (grado === 0) {\n        // Se la funzione non ha la x\n        const disequazione = `${parte}>0`;\n        disequazioni.push(disequazione);\n\n        code += this.toLatex(`${MathSolver.numeroRazionale(parte)}>0`);\n\n        code += `<hr>`;\n      } else if (grado === 1) {\n        // Se la funzione è di primo grado\n        // Risolvo la disequazione solamente spostando dal primo al secondo membro\n        const secondoMembro =\n          (func.termineNoto() * -1) / func.termini[0].coefficiente;\n        const disequazione = `x>${secondoMembro}`;\n        disequazioni.push(disequazione);\n\n        code += this.toLatex(`x>${MathSolver.numeroRazionale(secondoMembro)}`);\n\n        code += `<hr>`;\n      } else if (grado === 2) {\n        // Se la funzione è di secondo grado\n        // La scrivo sotto forma di equazione\n        const equazione = `${parte}=0`;\n\n        code += this.toLatex(equazione);\n\n        const soluzioneEquazione = this.risolviEquazione(\n          equazione,\n          null,\n          \"y=0\",\n          false,\n          false,\n          false\n        );\n        const {\n          risultati,\n          a,\n          b,\n          delta,\n          code: codeEquazione,\n        } = soluzioneEquazione;\n\n        code += `<hr>`;\n        code += codeEquazione;\n        code += this.toLatex(`\\\\Delta = ${MathSolver.numeroRazionale(delta)}`);\n        code += `<hr>`;\n        code += this.toLatex(`a ${a > 0 ? \">\" : \"<\"} 0`);\n        code += this.toLatex(`\\\\Delta ${delta > 0 ? \">\" : \"<\"} 0`);\n        code += this.toLatex(`dis > 0`);\n        code += `<hr>`;\n\n        // Adesso risolvo la disequazione di secondo grado in base ai dati\n        if (a > 0) {\n          if (delta > 0) {\n            disequazioni.push(`x<` + risultati[0] + ` OR x>${risultati[1]}`);\n\n            code += this.toLatex(\n              `x<` +\n                MathSolver.numeroRazionale(risultati[0]) +\n                ` \\\\bigvee x>${MathSolver.numeroRazionale(risultati[1])}`\n            );\n          } else if (delta === 0) {\n            disequazioni.push(\"ALL_VALUES\");\n\n            code += this.toLatex(\n              `x \\\\neq ${MathSolver.numeroRazionale(((b * -1) / 2) * a)}`\n            );\n          } else if (delta < 0) {\n            disequazioni.push(\"ALL_VALUES\");\n\n            code += this.toLatex(`\\\\forall x \\\\in \\\\mathbb{R}`);\n          }\n        } else {\n          if (delta > 0) {\n            disequazioni.push(`x>${risultati[0]} OR x<` + risultati[1]);\n\n            code += this.toLatex(\n              `${MathSolver.numeroRazionale(risultati[0])}<x \\\\bigvee x<` +\n                MathSolver.numeroRazionale(risultati[1])\n            );\n          } else if (delta <= 0) {\n            disequazioni.push(\"NO_VALUES\");\n\n            code += this.toLatex(`\\\\nexists x \\\\in \\\\mathbb{R}`);\n          }\n        }\n\n        code += `<hr>`;\n      }\n    });\n\n    if (disequazioni.length === 0) {\n      return {\n        insiemePositivo: [],\n        insiemeNegativo: [],\n        insiemiInOrdine: [],\n        code: this.toLatex(`\\\\text{Impossibile risolvere la disequazione}`),\n      };\n    }\n\n    let {\n      insiemePositivo,\n      insiemeNegativo,\n      insiemiInOrdine,\n      code: codeTabella,\n    } = this.risolviDisequazioni(disequazioni, segnoPositivo, segnoNegativo);\n\n    code += codeTabella;\n\n    return { insiemePositivo, insiemeNegativo, insiemiInOrdine, code };\n  };\n\n  /**\n   * Metodo che trova gli insiemi positivi e gli insiemi negativi di una funzione\n   *\n   * @method\n   * @param {Funzione} funzione Funzione di cui calcolare gli insiemi positivi e negativi\n   * @name Funzione#positivitaENegativita\n   */\n  this.positivitaENegativita = function (funzione) {\n    let { insiemePositivo, insiemeNegativo, code } =\n      this.funzioneMaggioreDiZero(funzione);\n\n    funzione.insiemePositivo = insiemePositivo;\n    funzione.insiemeNegativo = insiemeNegativo;\n\n    code += `<br>`;\n    code += this.toLatex(`I.P.=${this.insiemeToString(insiemePositivo)}`);\n    code += this.toLatex(`I.N.=${this.insiemeToString(insiemeNegativo)}`);\n\n    return code;\n  };\n\n  /**\n   * Metodo che trova gli insiemi di crescenza e decrescenza di una funzione\n   *\n   * @method\n   * @param {Funzione} funzione Funzione di cui calcolare gli insiemi di crescenza e decrescenza di una funzione\n   * @name Funzione#crescenzaEDecrescenza\n   */\n  this.crescenzaEDecrescenza = function (funzione) {\n    const derivata = funzione.derivata();\n\n    let code = ``;\n\n    code += this.toLatex(`f^{\\\\prime}(x)=${derivata.membri[1]}`);\n\n    let {\n      insiemePositivo,\n      insiemeNegativo,\n      insiemiInOrdine,\n      code: codeFunc,\n    } = this.funzioneMaggioreDiZero(derivata, \"⬈\", \"⬊\");\n\n    code += codeFunc;\n    code += `<br>`;\n\n    // Controllo tutti gli intervalli per capire dov'e' crescente e dove decrescente\n    // Prendo quelle dei punti massimi\n    // Prendo tutti gli intervalli positivi che sono seguiti da un intervallo negativo\n    let ascissePuntiMassimi = insiemiInOrdine\n      .filter(\n        (el, i) =>\n          el.positive &&\n          insiemiInOrdine[i + 1] &&\n          insiemiInOrdine[i + 1].negative\n      )\n      .map((el) => el.positive[1])\n      .filter((el) => el);\n    ascissePuntiMassimi = [...new Set(ascissePuntiMassimi)];\n\n    // E quelle dei punti minimi\n    // Prendo tutti gli intervalli negativi che sono seguiti da un intervallo positivo\n    let ascissePuntiMinimi = insiemiInOrdine\n      .filter(\n        (el, i) =>\n          el.negative &&\n          insiemiInOrdine[i + 1] &&\n          insiemiInOrdine[i + 1].positive\n      )\n      .map((el) => el.negative[1])\n      .filter((el) => el);\n    ascissePuntiMinimi = [...new Set(ascissePuntiMinimi)];\n\n    if (insiemePositivo.length > 0) {\n      code += this.toLatex(\n        `\\\\text{La funzione è crescente in } ${this.insiemeToString(\n          insiemePositivo\n        )}`\n      );\n    }\n\n    const puntiMassimi = ascissePuntiMassimi.map((x) =>\n      this.aggiungiPunto(x, math.parse(funzione.membri[1]).evaluate({ x }))\n    );\n\n    if (puntiMassimi.length > 0) {\n      code += this.toLatex(`\\\\text{La funzione ha punti di massimo in: }`);\n      code += puntiMassimi\n        .map((p) =>\n          this.toLatex(\n            `${p.nome}(${MathSolver.numeroRazionale(\n              p.x\n            )};${MathSolver.numeroRazionale(p.y)})`\n          )\n        )\n        .join(\" , \");\n    }\n\n    if (insiemeNegativo.length > 0) {\n      code += this.toLatex(\n        `\\\\text{La funzione è decrescente in } ${this.insiemeToString(\n          insiemeNegativo\n        )}`\n      );\n    }\n\n    const puntiMinimi = ascissePuntiMinimi.map((x) =>\n      this.aggiungiPunto(x, math.parse(funzione.membri[1]).evaluate({ x }))\n    );\n\n    if (puntiMinimi.length > 0) {\n      code += this.toLatex(`\\\\text{La funzione ha punti di minimo in: }`);\n      code += puntiMinimi\n        .map((p) =>\n          this.toLatex(\n            `${p.nome}(${MathSolver.numeroRazionale(\n              p.x\n            )};${MathSolver.numeroRazionale(p.y)})`\n          )\n        )\n        .join(\" , \");\n    }\n\n    return code;\n  };\n\n  /**\n   * Metodo che trova la concavita di una funzione\n   *\n   * @method\n   * @param {Funzione} funzione Funzione di cui trovare la concavita'\n   * @name Funzione#concavitaFunzione\n   */\n  this.concavitaFunzione = function (funzione) {\n    const derivata = funzione.derivata(2);\n\n    let code = ``;\n\n    code += this.toLatex(`f^{\\\\prime\\\\prime}(x)=${derivata.membri[1]}`);\n\n    let {\n      insiemePositivo,\n      insiemeNegativo,\n      code: codeFunc,\n    } = this.funzioneMaggioreDiZero(derivata, \"⬈\", \"⬊\");\n\n    code += codeFunc;\n    code += `<br>`;\n\n    if (insiemePositivo.length > 0) {\n      code += this.toLatex(\n        `\\\\text{La funzione ha la concavità rivolta verso l'alto (è convessa) in } ${this.insiemeToString(\n          insiemePositivo\n        )}`\n      );\n    }\n\n    if (insiemeNegativo.length > 0) {\n      code += this.toLatex(\n        `\\\\text{La funzione ha la concavità rivolta verso il basso (è concava) in } ${this.insiemeToString(\n          insiemeNegativo\n        )}`\n      );\n    }\n\n    return code;\n  };\n  /**\n   * Metodo che calcola l'area di una funzione in un'intervallo\n   *\n   * @method\n   * @param {Funzione} funzione Funzione di cui calcolare l'area\n   * @param {Array<Punto>} punti Punti dell'intervallo\n   */\n  this.areaFunzione = function (funzione, punti) {\n    if (punti.length < 2) {\n      return this.toLatex(`\\\\text{Impossibile trovare l'area!}`);\n    }\n\n    punti.sort((a, b) => a.x - b.x);\n\n    const secondoMembroFunzione = funzione.membri[1];\n    const primitiva = funzione.primitiva();\n    const funzionePrimitiva = primitiva.func;\n\n    const ascisse = [...new Set(punti.map((p) => p.x))];\n    const primitiveCalcolate = {};\n    let primitiveCalcolateCode = ``;\n\n    ascisse.forEach((ascissa) => {\n      const primitivaDaParsare = funzionePrimitiva\n        .toString(false)\n        .replace(\"y=\", \"\");\n\n      const primitivaCalcolata = math.parse(primitivaDaParsare).evaluate({\n        x: ascissa,\n      });\n\n      primitiveCalcolate[ascissa] = primitivaCalcolata;\n\n      const ascissaRazionale = MathSolver.numeroRazionale(ascissa);\n      primitiveCalcolateCode += this.toLatex(\n        `F(${ascissaRazionale})=${funzionePrimitiva\n          .toString(true)\n          .replace(/x/g, `(${ascissaRazionale})`)}=${MathSolver.numeroRazionale(\n          primitivaCalcolata\n        )}`\n      );\n    });\n\n    let soluzioniIntegrali = ``;\n    let soluzioneFinale = 0;\n\n    const integrali = punti\n      .filter((_, i) => i !== punti.length - 1)\n      .map((p, i) => {\n        const a = p.x;\n        const b = punti[i + 1].x;\n        const aRazionale = MathSolver.numeroRazionale(a);\n        const bRazionale = MathSolver.numeroRazionale(b);\n\n        const Fb = primitiveCalcolate[b];\n        const Fa = primitiveCalcolate[a];\n        const res = Fb - Fa;\n\n        soluzioniIntegrali +=\n          this.toLatex(\n            `\\\\int_{${aRazionale}}^{${bRazionale}} f(x) dx = F(${bRazionale}) - F(${aRazionale}) =${MathSolver.numeroRazionale(Fb)} - ${MathSolver.numeroRazionale(\n              Fa\n            )} = ${MathSolver.numeroRazionale(res)}`\n          ) + \"\\n\";\n\n        const code = `\\\\int_{${aRazionale}}^{${bRazionale}} f(x) dx`;\n        soluzioneFinale += Math.abs(res);\n\n        return {\n          code,\n          res,\n        };\n      });\n\n      let ultimoPassaggio = ``;\n      let integraliToString = ``;\n\n      integrali\n      .forEach((integrale, index) => {\n        ultimoPassaggio += MathSolver.numeroRazionale(Math.abs(integrale.res));\n        integraliToString += integrale.code;\n\n        if(index < (integrali.length - 1)) {\n          const separator = integrali[index + 1] && integrali[index + 1].res < 0 ? ' - ' : ' + ';\n          \n          ultimoPassaggio += ' + ';\n          integraliToString += separator;\n        }\n      })\n\n    let code = ``;\n\n    // Scrivo la funzione\n    code += this.toLatex(`f(x)=${secondoMembroFunzione}`);\n    // Poi scrivo la primitiva con tutti i passaggi per trovarla\n    code += primitiva.passaggi.map((p) => this.toLatex(p, true)).join(\"\\n\");\n\n    // Adesso calcolo la primitiva per ogni ascissa\n    code += primitiveCalcolateCode;\n    code += soluzioniIntegrali;\n\n    code += `<hr>`;\n    code += this.toLatex(\n      `Area = \\\\int_{${MathSolver.numeroRazionale(\n        punti[0].x\n      )}}^{${MathSolver.numeroRazionale(punti[punti.length - 1].x)}} f(x) dx`\n    );\n\n    if (integrali.length > 1) {\n      code += this.toLatex(\n        `Area = ${integraliToString}`\n      );\n    }\n\n    code += this.toLatex(`Area = ${ultimoPassaggio}`);\n    code += this.toLatex(\n      `\\\\textbf{Area = } \\\\mathbf{${MathSolver.numeroRazionale(\n        soluzioneFinale\n      )}}`\n    );\n\n    return code;\n  };\n\n  /**\n   * Metodo che aggiunge le funzioni e i punti specifici per una parabola\n   *\n   * @method\n   * @param {Funzione} funzione Funzione di cui fare le aggiunte specifiche\n   *\n   * @returns {Array.<string>} Funzioni da aggiungere al grafico\n   */\n  this.aggiunteSpecificheParabola = function (funzione) {\n    // Equazione parabola: y=ax^2+bx+c\n    // Per la parabola bisogna calcolare il fuoco, il vertice, la direttrice e l'asse di simmetria\n    let a = funzione.getByExp(2);\n    a = a ? a.coefficiente : 0;\n\n    let b = funzione.getByExp(1);\n    b = b ? b.coefficiente : 0;\n\n    const c = funzione.termineNoto();\n\n    const delta = Math.pow(b, 2) - 4 * a * c;\n\n    // I due punti hanno la stessa ascissa\n    const x = (b * -1) / (2 * a);\n\n    const vertice = {\n      x,\n      y: (delta * -1) / (4 * a),\n    };\n\n    const fuoco = {\n      x,\n      y: (1 - delta) / (4 * a),\n    };\n\n    this.aggiungiPunto(vertice.x, vertice.y, \"V\");\n    this.aggiungiPunto(fuoco.x, fuoco.y, \"F\");\n\n    // Per il momento non lo torno perche' se li visualizzo tutti e due il grafico da problemi\n    const direttrice = `y=${((1 + delta) / (4 * a)) * -1}`;\n    // const asseDiSimmetria = `x=${x}`;\n\n    return [direttrice];\n  };\n\n  /**\n   * Metodo che aggiunge le funzioni e i punti specifici, ad esempio la direttrice della parabola e il vertice\n   *\n   * @method\n   * @param {Funzione} funzione Funzione di cui fare le aggiunte specifiche\n   */\n  this.aggiunteSpecifiche = function (funzione) {\n    if (funzione.isParabola()) {\n      return this.aggiunteSpecificheParabola(funzione);\n    }\n\n    return [];\n  };\n}\n\n/**\n * Divide l'espressione in ogni termine di cui è composta in base a dei caratteri delimitanti\n *\n * @param {string} espressione\n * @param {Array.<string>} caratteri Caratteri delimitanti\n * @name MathSolver#splittaEspressione\n * @static\n */\nMathSolver.splittaEspressione = function (espressione, caratteri) {\n  let split = [];\n  let stringa = \"\";\n\n  for (let i = 0; i < espressione.length; i++) {\n    // leggo ogni carattere dell'espressione\n    const carattere = espressione[i];\n\n    if (!caratteri.includes(espressione[i]) || i == 0) {\n      // Se non è un carattere da splittare e non è il primo carattere dell'espressione\n      stringa += espressione[i];\n    } else {\n      split.push(stringa); // Aggiungiamo la stringa nell'array\n      stringa = `${carattere}`; // Svuotiamo la stringa\n    }\n\n    if (i == espressione.length - 1) {\n      // Se sono all'ultimo carattere e non ho trovato nulla da splittare\n      split.push(stringa); // Aggiungiamo la stringa nell'array\n    }\n  }\n\n  return split;\n};\n\nMathSolver.numeroInFrazione = function (value) {\n  const gcd = function (a, b) {\n    if (b < 0.0000001) return a;\n\n    return gcd(b, Math.floor(a % b));\n  };\n\n  const fraction = Math.abs(parseFloat(parseFloat(value).toFixed(2)));\n  const len = fraction.toString().length - 2;\n\n  let denominator = Math.pow(10, len);\n  let numerator = fraction * denominator;\n\n  const divisor = gcd(numerator, denominator);\n\n  numerator /= divisor;\n  denominator /= divisor;\n\n  return { n: numerator, d: denominator };\n};\n\n/**\n * Metodo che ritorna il numero sotto forma di frazione.\n * Al momento questa funzione non fa nulla per continuare il corretto funzionamento del programma in quanto ci sono degli errori\n *\n * @method\n * @name MathSolver#numeroRazionale\n * @param {number} value Numero da controllare\n * @returns {*} Numero sotto forma di frazione\n * @static\n */\nMathSolver.numeroRazionale = function (value) {\n  if (value == undefined) {\n    return \"1\";\n  }\n\n  if (\n    value.toString().includes(\"Infinity\") ||\n    Number.isNaN(parseFloat(value))\n  ) {\n    return value;\n  }\n\n  const numeroConDueDecimali = parseFloat(value.toString())\n    .toFixed(2)\n    .replace(\".00\", \"\");\n\n  const frazione = MathSolver.numeroInFrazione(value);\n\n  if (frazione.d === 1) {\n    return numeroConDueDecimali;\n  }\n\n  const numeratore = frazione.n.toString();\n  const denominatore = frazione.d.toString();\n\n  // Se il denominatore o il numeratore sono troppo grandi ritorno il numero con due decimali\n  const maxLarge = 2;\n  if (numeratore.length > maxLarge || denominatore.length > maxLarge) {\n    return numeroConDueDecimali;\n  }\n\n  const simbolo = value < 0 ? \"-\" : \"\";\n  return `${simbolo}\\\\frac{${numeratore}} {${denominatore}}`;\n};\n\n\n\n\n//# sourceURL=webpack://mathsolver/./src/js/mathsolver.js?");

/***/ }),

/***/ "./src/js/parte-letterale.js":
/*!***********************************!*\
  !*** ./src/js/parte-letterale.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParteLetterale\": () => (/* binding */ ParteLetterale)\n/* harmony export */ });\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo ParteLetterale\n * \n * @typedef {Object} ParteLetteraleOptions\n * @property {string} lettera - Lettera della parte letterale\n * @property {number} esponente - Esponente della parte letterale\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Questa classe serve a definire la parte letterale intpretata da un'espressione, letta come stringa\n * \n * @class ParteLetterale\n * @classdesc ParteLetterale di un termine\n * @param {ParteLetteraleOptions|string} options Opzioni per inizializzare la parte letterale\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\nfunction ParteLetterale(options) {\n    /**\n     * Letterale della parte letterale\n     * \n     * @name ParteLetterale#lettera\n     * @type {string}\n     * @default 0\n     */\n    this.lettera = null;\n    /**\n     * Esponente della parte letterale\n     * \n     * @name ParteLetterale#esponente\n     * @type {number}\n     * @default {}\n     */\n    this.esponente = 0;\n\n    switch (typeof(options)) { // In base al tipo di dato delle opzioni che sono state passate\n        case 'string': // Se ha passato una stringa\n            // Intrepreto la stringa e mi prendo i dati necessari\n            ParteLetterale.interpreta(options, this);\n            break;\n        default: // Se ha passato un oggetto di tipo ParteLetteraleOptions\n            // Prendo le opzioni\n            this.lettera = options.lettera;\n            this.esponente = options.esponente;\n    }\n\n    /**\n     * Metodo che ritorna la parte letterale come stringa.\n     * Molto utile nel caso in cui la parte letterale sia stata modificata da uno dei metodi per poterlo stampare a schermo con le modifiche\n     * \n     * @method\n     * @name ParteLetterale#toString\n     * @returns {string} Parte letterale scritta sotto forma di stringa\n     */\n    this.toString = function() {\n        if(!this.lettera) {\n            return ``;\n        }\n        \n        if (this.esponente !== 0) {\n            if (this.esponente !== 1) {\n                return `${this.lettera}^${this.esponente}`;\n            } else {\n                return `${this.lettera}`;\n            }\n        } else {\n            return this.lettera;\n        }\n    }\n}\n\n/**\n * Interpreta la parte letterale scritta come stringa.\n * Serve nel caso in cui si passi una stringa al costruttore e si voglia fare il passaggio di interpretazione in automatico\n * \n * @param {string} parteLetterale Parte letterale da intepretare\n * @param {ParteLetterale} [obj] Oggetto da modificare\n * @name ParteLetterale#interpreta\n * @static\n * @returns {ParteLetterale} Parte letterale interpretata\n */\nParteLetterale.interpreta = function(parteLetterale, obj) {\n    // Se non c'è nessuna parte letterale\n    if (parteLetterale == null) {\n        if (obj) { // Se devo modificare un oggetto\n            obj = null;\n        }\n\n        return null;\n    }\n\n    let split = parteLetterale.split('^');\n    let esponente = 1;\n    let lettera = split[0];\n\n    if (split.length > 1) {\n        esponente = parseFloat(split[1]);\n    }\n\n    if (obj) { // Se devo modificare un oggetto\n        obj.lettera = lettera;\n        obj.esponente = esponente;\n\n        return obj;\n    } else { // Altrimenti\n        return new ParteLetterale({\n            lettera: lettera,\n            esponente: esponente\n        });;\n    }\n}\n\n\n\n//# sourceURL=webpack://mathsolver/./src/js/parte-letterale.js?");

/***/ }),

/***/ "./src/js/termine.js":
/*!***************************!*\
  !*** ./src/js/termine.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Termine\": () => (/* binding */ Termine)\n/* harmony export */ });\n/* harmony import */ var _parte_letterale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parte-letterale */ \"./src/js/parte-letterale.js\");\n\nwindow.ParteLetterale = _parte_letterale__WEBPACK_IMPORTED_MODULE_0__.ParteLetterale;\n\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo Termine\n * \n * @typedef {Object} TermineOptions\n * @property {number} coefficiente - Coefficiente del termine\n * @property {ParteLetterale} parteLetterale - Parte letterale del termine\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Questa classe serve a definire i termini interpretati da un'espressione, letta come stringa\n * \n * @class Termine\n * @classdesc Termine di un'espressione\n * @param {TermineOptions|string} options Opzioni per inizializzare un termine\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\nfunction Termine(options) {\n    /**\n     * Coefficiente del termine (il numero scritto accanto alla parte letterale)\n     * \n     * @name Termine#coefficiente\n     * @type {number}\n     * @default 0\n     */\n    this.coefficiente = 0;\n    /**\n     * Parte letterale del termine, è divisa a sua volta in lettera ed esponente\n     * \n     * @name Termine#parteLetterale\n     * @type {ParteLetterale}\n     * @default {}\n     */\n    this.parteLetterale = {};\n\n    switch (typeof(options)) { // In base al tipo di dato delle opzioni che sono state passate\n        case 'string': // Se ha passato una stringa\n            // Intrepreto la stringa e mi prendo i dati necessari\n            Termine.interpreta(options, this);\n            break;\n        default: // Se ha passato un oggetto di tipo TermineOptions\n            // Prendo le opzioni\n            this.coefficiente = options.coefficiente;\n            this.parteLetterale = options.parteLetterale;\n    }\n\n    /**\n     * Metodo che ritorna il termine come stringa.\n     * Molto utile nel caso in cui il termine sia stata modificato da uno dei metodi per poterlo stampare a schermo con le modifiche\n     * \n     * @method\n     * @param {boolean} numeroRazionale Se convertire i numeri in frazioni\n     * @returns {string} Termine scritto sotto forma di stringa\n     */\n    this.toString = function(numeroRazionale = false) {\n        let string;\n\n        if (this.coefficiente == 1) {\n            if(this.parteLetterale) {\n                string = `+${this.parteLetterale.toString()}`;\n            }else {\n                string = `+1`;\n            }\n        } else if (this.coefficiente == -1) {\n            if(this.parteLetterale) {\n                string = `-${this.parteLetterale.toString()}`;\n            }else {\n                string = `-1`;\n            }\n        } else {\n            if(numeroRazionale) {\n                string = MathSolver.numeroRazionale(this.coefficiente);\n            }else {\n                string = `${this.coefficiente}`;\n            }\n\n            if(this.coefficiente > 0) {\n                string = `+${string}`;\n            }\n            \n            if(this.parteLetterale) {\n                string += this.parteLetterale.toString();\n            }\n        }\n\n        return string;\n    }\n\n    /**\n     * Metodo che ritorna il termine come stringa.\n     * Elimina il + se è il primo carattere\n     * \n     * @method\n     * @returns {string} Termine, con tolto il + se è il primo carattere\n     */\n    this.toStringWithoutPlus = function() {\n        let stringa = this.toString();\n\n        if (stringa[0] == '+') {\n          return stringa.substring(1);\n        }\n\n        return stringa;\n    }\n}\n\n/**\n * Interpreta un termine scritta come stringa.\n * Serve nel caso in cui si passi una stringa al costruttore e si voglia fare il passaggio di interpretazione in automatico\n * \n * @param {string} termine Termine da intepretare\n * @param {Termine} [obj] Oggetto da modificare\n * @name Termine#interpreta\n * @static\n * @returns {Termine} Termine interpretato\n */\nTermine.interpreta = function(termine, obj) {\n    let coefficiente = '';\n    let parteLetterale = '';\n    let prendiCoefficiente = true;\n\n    for (let i = 0; i < termine.length; i++) { // Leggo tutti i caratteri del termine\n        // Se è una lettera\n        if (termine[i].isAlpha()) {\n            prendiCoefficiente = false; // Smettiamo di prendere il coefficiente\n        }\n\n        if (prendiCoefficiente) { // Se posso prendere il coefficiente\n            coefficiente += termine[i];\n        } else { // Altrimenti\n            parteLetterale += termine[i];\n        }\n    }\n\n    switch (coefficiente) { // In base al valore del coefficiente\n        case '+':\n        case '':\n            // Se non c'è o è un + vale 1\n            coefficiente = 1;\n            break;\n        case '-':\n            // Se è un meno vale -1\n            coefficiente = -1;\n            break;\n        default:\n            // Altrimenti lo intrepreto come float\n            coefficiente = parseFloat(coefficiente);\n    }\n\n    if (parteLetterale == '') parteLetterale = null;\n    parteLetterale = _parte_letterale__WEBPACK_IMPORTED_MODULE_0__.ParteLetterale.interpreta(parteLetterale);\n\n    if (obj) { // Se devo modificare un oggetto\n        obj.coefficiente = coefficiente;\n        obj.parteLetterale = parteLetterale;\n\n        return obj;\n    } else { // Altrimenti\n        return new Termine({\n            coefficiente: coefficiente,\n            parteLetterale: parteLetterale\n        });;\n    }\n}\n\n\n\n//# sourceURL=webpack://mathsolver/./src/js/termine.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	__webpack_exports__ = __webpack_exports__.default;
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});