/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_js_mathsolver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/js/mathsolver */ \"./src/js/mathsolver.js\");\n/* harmony import */ var _src_js_grafico__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/js/grafico */ \"./src/js/grafico.js\");\n\n\n\nwindow.MathSolver = _src_js_mathsolver__WEBPACK_IMPORTED_MODULE_0__.MathSolver;\nwindow.Grafico = _src_js_grafico__WEBPACK_IMPORTED_MODULE_1__.Grafico;\n\n//# sourceURL=webpack://mathsolver/./index.js?");

/***/ }),

/***/ "./src/js/funzione.js":
/*!****************************!*\
  !*** ./src/js/funzione.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Funzione\": () => (/* binding */ Funzione)\n/* harmony export */ });\n/* harmony import */ var _parte_letterale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parte-letterale */ \"./src/js/parte-letterale.js\");\n/* harmony import */ var _termine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./termine */ \"./src/js/termine.js\");\n\n\nwindow.Termine = _termine__WEBPACK_IMPORTED_MODULE_1__.Termine;\n\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo Funzione\n * \n * @typedef {Object} FunzioneOptions\n * @property {Array.<Membro>} membri - membri di cui è composta la funzione\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Membro di una funzione\n * \n * @typedef {Object} Membro\n * @property {Array.<Termine>} numeratore - Numeratore del membro\n * @property {Array.<Termine>} denominatore - Numeratore del membro (nel caso in cui non ci sia una funzione fratta è 1)\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Questa classe serve a definire le funzioni interpretate a partire da una stringa.\n * Si trova quindi i membri di ogni equazione e tutti i termini che ne fanno parte.\n * Aggiunge inoltre dei metodi molto utili per lavorare con le funzioni matematiche, come ad esempio l'ordinazione e la ricerca del termine noto.\n * Al posto di una funzione si può interpretare un'equazione allo stesso modo\n * \n * @class Funzione\n * @classdesc Funzione matematica\n * @param {FunzioneOptions|string} options Opzioni per inizializzare una funzione\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\nfunction Funzione(options) {\n    /**\n     * Membri di cui è composta la funzione.\n     * Ogni membro è composto da numeratore e denominatore, a loro volta composti da termini\n     * \n     * @name Funzione#membri\n     * @type {Array.<Membro>}\n     * @default []\n     */\n    this.membri = [];\n\n    switch (typeof(options)) { // In base al tipo di dato delle opzioni che sono state passate\n        case 'FunzioneOptions': // Se ha passato un oggetto di tipo FunzioneOptions\n            // Prendo le opzioni\n            this.membri = options.membri;\n            break;\n        case 'string': // Se ha passato una stringa\n            // Intrepreto la stringa e mi prendo i dati necessari\n            Funzione.interpreta(options, this);\n            break;\n        default:\n            throw 'Per favore passa un oggetto di tipo FunzioneOptions oppure una stringa!';\n    }\n\n    /**\n     * Metodo che ritorna il termine noto della funzione.\n     * Va a cercare tra tutti i termini quello che non ha una parte letterale così da poter tornare poi il coefficiente.\n     * \n     * @method\n     * @name Funzione#termineNoto\n     * @returns {number} Termine noto\n     */\n    this.termineNoto = function() {\n        let termine = 0;\n        for (let i = 0; i < this.membri[1].numeratore.length; i++) {\n            if (this.membri[1].numeratore[i].parteLetterale == null) return this.membri[1].numeratore[i].coefficiente;\n        }\n        return termine;\n    }\n\n    /**\n     * Metodo che ritorna il grado della funzione\n     * \n     * @method\n     * @name Funzione#grado\n     * @return {number} Grado della funzione\n     */\n    this.grado = function() {\n        // Cerco tra tutti i termini quello con il grado maggiore\n        let elencoTermini = [];\n        this.membri.forEach(membro => {\n            membro.numeratore.forEach(termine => {\n                elencoTermini.push(termine);\n            });\n\n            membro.denominatore.forEach(termine => {\n                elencoTermini.push(termine);\n            })\n        })\n\n        return Math.max(...elencoTermini.map(termine => {\n            if (termine.parteLetterale) {\n                return termine.parteLetterale.esponente;\n            } else {\n                return 0;\n            }\n        }));\n    }\n\n    /**\n     * Metodo che ritorna il termine con un determinato esponente nella parte letterale\n     * \n     * @method\n     * @name Funzione#getByExp\n     * @param {number} exp Esponente che deve avere il termine nella parte letterale\n     * @return {Termine} Termine con quell'esponente\n     */\n    this.getByExp = function(exp, membro = 1) {\n        let elencoTermini = [];\n        membro = this.membri[membro];\n        membro.numeratore.forEach(termine => {\n            elencoTermini.push(termine);\n        });\n\n        membro.denominatore ? membro.denominatore.forEach(termine => {\n            elencoTermini.push(termine);\n        }) : null;\n\n        let result = elencoTermini.filter(termine => {\n            if (termine.parteLetterale) {\n                return termine.parteLetterale.esponente == exp;\n            }\n        });\n        if (result.length == 1) return result[0];\n        return result;\n    }\n\n    /**\n     * Metodo che ordina l'array di termini in modo decrescente in base all'esponente della parte letterale\n     * Non ritorna nulla perché modifica direttamente l'oggetto\n     * \n     * @method\n     * @name Funzione#ordina\n     */\n    this.ordina = function() {\n        // Ordino l'array dei termini in modo decrescente in base all'esponente della parte letterale\n        // Devo ordinare quindi i termini del numeratore e del denominatore di ogni membro\n        this.membri.forEach(membro => {\n            membro.numeratore.sort((a, b) => (b.parteLetterale ? b.parteLetterale.esponente : 0) - (a.parteLetterale ? a.parteLetterale.esponente : 0));\n            membro.denominatore ? membro.denominatore.sort((a, b) => (b.parteLetterale ? b.parteLetterale.esponente : 0) - (a.parteLetterale ? a.parteLetterale.esponente : 0)) : null;\n        });\n    }\n\n    /**\n     * Metodo che completa la funzione aggiungendo gli esponenti mancanti in modo tale che ci sia un termine per ogni esponente a partire dal grado della funzione\n     * Es: x^3+0x^2+x\n     * \n     * @method\n     * @name Funzione#completa\n     */\n    this.completa = function() {\n        const gradoFunzione = this.grado(); // Prendo il grado\n        const complete = (parteFrazione) => {\n            for (let i = gradoFunzione; i > 0; i--) { // Parto dal grado fino ad esponente 1\n                // Se non c'è un termine con questo esponente\n                if (parteFrazione.filter(termine => {\n                        if (termine.parteLetterale) {\n                            return termine.parteLetterale.esponente == i;\n                        }\n                    }).length == 0) {\n                    // Lo aggiungo\n                    parteFrazione.push(new _termine__WEBPACK_IMPORTED_MODULE_1__.Termine({\n                        coefficiente: 0,\n                        parteLetterale: new _parte_letterale__WEBPACK_IMPORTED_MODULE_0__.ParteLetterale({\n                            lettera: 'x',\n                            esponente: i\n                        })\n                    }));\n                }\n            }\n            // Se manca il coefficiente\n            if (parteFrazione.length < (gradoFunzione + 1)) {\n                // Lo aggiungo\n                parteFrazione.push(new _termine__WEBPACK_IMPORTED_MODULE_1__.Termine({\n                    coefficiente: 0,\n                    parteLetterale: new _parte_letterale__WEBPACK_IMPORTED_MODULE_0__.ParteLetterale({\n                        lettera: 'x',\n                        esponente: 0\n                    })\n                }));\n            }\n        };\n\n        // Completo tutti i membri\n        this.membri.forEach(membro => {\n            // E per ogni membro completo sia il numeratore che il denominatore\n            complete(membro.numeratore);\n            complete(membro.denominatore);\n        });\n\n        // Ordino la funzione\n        this.ordina();\n    }\n\n    /**\n     * Metodo che ritorna il coefficiente angolare di una retta.\n     * Se la funzione non è una retta ritorna null\n     * \n     * @method\n     * @name Funzione#coefficienteAngolare\n     */\n    this.coefficienteAngolare = function() {\n        if (this.grado() !== 1) { // Se non è una retta\n            return null;\n        }\n\n        // Prendo il coefficiente del termine di grado 1\n        const coefficiente = this.getByExp(1).coefficiente;\n        let radianti = Math.atan(coefficiente);\n        let gradi = radianti * 180 / Math.PI;\n\n        return {\n            numero: coefficiente,\n            gradi: gradi,\n            radianti: radianti,\n            angoloAcuto: coefficiente > 0,\n            angoloRetto: coefficiente == 0,\n            angoloOttuso: coefficiente < 0\n        }\n    }\n\n    /**\n     * Metodo che trova il dominio della funzione\n     * \n     * @method\n     * @name Funzione#dominio\n     */\n    this.dominio = function() {\n\n    }\n\n    /**\n     * Metodo che trova la tipologia della funzione\n     * \n     * @method\n     * @name Funzione#tipologia\n     */\n    this.tipologia = function() {\n\n    }\n\n    /**\n     * Metodo che semplifica la funzione\n     * \n     * @method\n     * @name Funzione#semplifica\n     */\n    this.semplifica = function() {\n        const semplificaParteFrazione = (parte) => {\n            // Se ci sono termini che hanno la stessa esatta parte letterale sommo i coefficienti e trovo un nuovo termine\n            let terminiDaTogliere = [];\n            let valori = {};\n\n            // Prendo tutti i termini\n            for (let i = 0; i < parte.length; i++) {\n                const parteLetteraleString = parte[i].parteLetterale ? parte[i].parteLetterale.toString() : ''; // parte letterale come stringa\n                // Se ho già memorizzato un valore per questa parte letterale, parto da quel valore + il coefficiente, altrimenti parto dal coefficiente\n                let valore = valori[parteLetteraleString] ? (valori[parteLetteraleString] + parte[i].coefficiente) : parte[i].coefficiente;\n\n                // Per ogni termine prendo il termine successivo\n                for (let j = i; j < parte.length; j++) {\n                    const parteLetteraleString2 = parte[j].parteLetterale ? parte[j].parteLetterale.toString() : '';\n                    if (parteLetteraleString == parteLetteraleString2) { // Se i due termini hanno la stessa parte letterale\n                        // Sommo il coefficiente\n                        valore += parte[j].coefficiente;\n                        terminiDaTogliere.push(parteLetteraleString);\n                        terminiDaTogliere.push(parteLetteraleString2);\n                    }\n                }\n\n                // memorizzo il valore\n                valori[parteLetteraleString] = valore;\n            }\n\n            // Aggiungo i termini nuovi\n            for (let key in Object.keys(valori)) {\n                parte.push(new _termine__WEBPACK_IMPORTED_MODULE_1__.Termine({\n                    coefficiente: valori[key],\n                    parteLetterale: new _parte_letterale__WEBPACK_IMPORTED_MODULE_0__.ParteLetterale(key)\n                }))\n            }\n\n            // Elimino tutti i termini che hanno coefficiente zero e quelli nella lista da tgogliere\n            parte = parte.filter(termine => !terminiDaTogliere.includes(termine.toString() && termine.coefficiente !== 0));\n        };\n\n        // Per ogni membro\n        this.membri.forEach(membro => {\n            // Semplifico il numeratore e il denominatore\n            semplificaParteFrazione(membro.numeratore);\n            semplificaParteFrazione(membro.denominatore);\n        });\n    }\n\n    /**\n     * Metodo che dice se la funzione è in forma esplicita\n     * \n     * @method\n     * @name Funzione#isFormaEsplicita\n     */\n    this.isFormaEsplicita = function() {\n        // La funzione è in forma esplicita quando a primo membro è presente solo la y di grado 1 e nessun altro termine\n        return this.membri[0].numeratore.length == 1 &&\n            this.membri[0].numeratore[0].parteLetterale.lettera == 'y' &&\n            this.membri[0].numeratore[0].parteLetterale.esponente == 1;\n    }\n\n    /**\n     * Metodo che dice se la funzione è in forma implicita\n     * \n     * @method\n     * @name Funzione#isFormaImplicita\n     */\n    this.isFormaImplicita = function() {\n        // Fondamentalmente una funzione è in forma implicita se non è in forma esplicita\n        return !this.isFormaEsplicita();\n    }\n\n    /**\n     * Metodo che trasforma la funzione in forma esplicita, utilizzato nelle rette\n     * \n     * @method\n     * @name Funzione#formaEsplicita\n     */\n    this.formaEsplicita = function() {\n        if (!this.isFormaEsplicita()) { // Se la funzione è già in forma esplicita non faccio nulla\n            // Per portare la funzione in forma esplicita sposto tutti i termini del primo membro al secondo membro tranne la y\n            this.membri[0].numeratore.forEach(termine => {\n                if (termine.parteLetterale.lettera == 'y' && termine.parteLetterale.esponente == 1) return;\n\n                this.membri[1].numeratore.push(new _termine__WEBPACK_IMPORTED_MODULE_1__.Termine({\n                    coefficiente: -termine.coefficiente,\n                    parteLetterale: termine.parteLetterale\n                }));\n            });\n\n            // Elimino tutto tranne la y al primo membro\n            this.membri[0].numeratore = this.membri[0].numeratore.filter(termine => termine.parteLetterale.lettera == 'y' && termine.parteLetterale.esponente == 1);\n\n            this.ordina(); // Ordino la funzione\n        }\n    }\n\n    /**\n     * Metodo che trasforma la funzione in forma implicita\n     * \n     * @method\n     * @name Funzione#formaImplicita\n     */\n    this.formaImplicita = function() {\n        if (!this.isFormaImplicita()) { // Se la funzione è giä in forma implicita non faccio nulla\n            // Per portare la funzione in forma implicita sposto tutti i termini del secondo membro al primo e nel secondo lascio lo zero\n            this.membri[1].numeratore.forEach(termine => {\n                this.membri[0].numeratore.push(new _termine__WEBPACK_IMPORTED_MODULE_1__.Termine({\n                    coefficiente: -termine.coefficiente,\n                    parteLetterale: termine.parteLetterale\n                }));\n            });\n\n            this.membri[1].numeratore = [\n                new _termine__WEBPACK_IMPORTED_MODULE_1__.Termine({\n                    coefficiente: 0,\n                    parteLetterale: null\n                })\n            ];\n\n            this.ordina(); // Ordino la funzione\n        }\n    }\n\n    /**\n     * Metodo che ritorna la funzione come stringa.\n     * Molto utile nel caso in cui la funzione sia stata modificata da uno dei metodi per poterla stampare a schermo con le modifiche\n     * \n     * @method\n     * @name Funzione#toString\n     * @returns {string} Funzione scritta sotto forma di stringa\n     */\n    this.toString = function() {\n        /**\n         * Funzione che stampa a schermo un membro\n         * \n         * @param {*} membro \n         */\n        const membroString = (membro) => {\n            /**\n             * Funzione che stampa a schermo una parte della frazione\n             * \n             * @param {*} frazione \n             */\n            const terminiString = (termini) => {\n                let string = ``;\n                termini.forEach(termine => {\n                    string += termine.toString();\n                });\n\n                // Se il primo carattere è un +  lo rimuovo\n                if (string[0] == '+') string = string.substring(1);\n                return string;\n            };\n\n            let string = ``;\n\n            // Se il denominatore è presente\n            if (membro.denominatore ? membro.denominatore.length > 0 : false) {\n                // Stampo a schermo il numeratore e il denominatore\n                string += `\\\\frac {${terminiString(membro.numeratore)}} {${terminiString(membro.denominatore)}}`;\n            } else { // Altrimenti\n                string += terminiString(membro.numeratore);\n            }\n\n            return string;\n        };\n\n        return `${membroString(this.membri[0])}=${membroString(this.membri[1])}`;\n    }\n}\n\n/**\n * Interpreta una funzione scritta come stringa.\n * Serve nel caso in cui si passi una stringa al costruttore e si voglia fare il passaggio di interpretazione in automatico\n * \n * @param {string} funzione Funzione da intepretare\n * @param {Funzione} [obj] Oggetto da modificare\n * @name Funzione#interpreta\n * @static\n * @returns {Funzione} Funzione interpretata\n */\nFunzione.interpreta = function(funzione, obj) {\n    funzione = funzione.trim(); // Levo tutti gli spazi dalla funzione\n    let membri = funzione.split('='); // Prendo i membri separando dall'uguale\n    // Intepretro ogni membro\n    const interpretaMembro = function(membro) {\n        let numeratore;\n        let denominatore;\n        let partiStringa;\n\n        const interpretaEspressione = (espressione) => {\n            // Splitto per il + o per il - l'espressione in più termini (es. termine con la x^2 ecc...)\n            partiStringa = MathSolver.splittaEspressione(espressione, ['+', '-']);\n\n            return partiStringa.map(string => _termine__WEBPACK_IMPORTED_MODULE_1__.Termine.interpreta(string));\n        };\n\n        // Se il membro contiene una frazione\n        if (membro.includes('frac')) {\n            const getWordsBetweenCurlies = (str) => {\n                var results = [],\n                    re = /{([^}]+)}/g,\n                    text;\n\n                while (text = re.exec(str)) {\n                    results.push(text[1]);\n                }\n                return results;\n            };\n            let membriFrazione = getWordsBetweenCurlies(membro);\n            numeratore = interpretaEspressione(membriFrazione[0]);\n            denominatore = interpretaEspressione(membriFrazione[1]);\n        } else { // Altrimenti\n            // Adesso divido ogni termine in parte letterale e numerica\n            numeratore = interpretaEspressione(membro);\n            denominatore = null;\n        }\n\n        return {\n            numeratore: numeratore,\n            denominatore: denominatore\n        };\n    };\n\n    membri = membri.map(membro => interpretaMembro(membro));\n\n    if (obj) { // Se devo modificare un oggetto\n        obj.membri = membri;\n\n        return obj;\n    } else { // Altrimenti\n        return new Funzione({\n            membri: membri\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack://mathsolver/./src/js/funzione.js?");

/***/ }),

/***/ "./src/js/grafico.js":
/*!***************************!*\
  !*** ./src/js/grafico.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Grafico\": () => (/* binding */ Grafico)\n/* harmony export */ });\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo Grafico\n * \n * @typedef {Object} AsseGraficoOptions\n * @property {number} min=-20 - Valore minimo dell'asse\n * @property {number} max=20 - Valore massimo dell'asse\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Colori che devono avere gli elementi nel grafico\n * \n * @typedef {Object} ColoriGraficoOptions\n * @property {string} assi='#444444' - Colore che devono avere gli assi\n * @property {string} punti='#DD4B44' - Colore che devono avere i punti\n * @property {string} puntiFunzione='4D4DFF' - Colore che devono avere i punti trovati della funzione\n * @property {string} funzione='#484848' - Colore che deve avere la funzione\n * @property {string} testo='#444444'\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Opzioni dell'animazione del grafico\n * \n * @typedef {Object} AnimazioneGraficoOptions\n * @property {boolean} animazione=false - Se utilizzare un'animazione\n * @property {boolean} loop=false - Se l'animazione deve essere in loop\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo Grafico\n * \n * @typedef {Object} GraficoOptions\n * @property {Array.<AsseGraficoOptions>} assi - Opzioni degli assi\n * @property {ColoriGraficoOptions} colori - Colori da avere nel grafico\n * @property {string} font='Poppins' - Font utilizzato nel testo\n * @property {number} focus=3 - Focus della fotocamera\n * @property {AnimazioneGraficoOptions} animazione - Opzioni dell'animazione\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Questa classe serve a gestire la visualizzazione del grafico\n * \n * @class Grafico\n * @classdesc Termine di un'espressione\n * @param {GraficoOptions} options Opzioni per la visualizzazione del grafico\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\nfunction Grafico(options) {\n    if (options == null || options == undefined) options = {};\n\n    // Carico i valori di default\n    options.font = options.font || 'Poppins';\n    if (options.focus == undefined || options.focus == null) options.focus = 3;\n\n    if (options.colori == undefined || options.colori == null) {\n        options.colori = {\n            assi: '#444444',\n            punti: '#f400a1',\n            puntiFunzione: '#4D4DFF',\n            funzione: '#484848',\n            testo: '#444444'\n        };\n    } else {\n        if (!options.colori) options.colori = '#444444';\n        if (!options.punti) options.punti = '#DD4B44';\n        if (!options.puntiFunzione) options.puntiFunzione = '#4D4DFF';\n        if (!options.funzione) options.funzione = '#484848';\n        if (!options.testo) options.testo = '#444444';\n    }\n\n    if (options.assi == undefined || options.assi == null) {\n        options.assi = [{\n                min: -20,\n                max: 20\n            },\n            {\n                min: -20,\n                max: 20\n            }\n        ];\n    } else {\n        for (let i = 0; i < options.assi.length; i++) {\n            if (options.assi[i] == undefined || options.assi[i] == null) {\n                options.assi[i] = {\n                    min: -20,\n                    max: 20\n                };\n            } else {\n                if (options.assi[i].min == undefined || options.assi[i].min == null) options.assi[i].min = -20;\n                if (options.assi[i].max == undefined || options.assi[i].max == null) options.assi[i].max = 20;\n            }\n        }\n    }\n\n    if (options.animazione == undefined || options.animazione == null) {\n        options.animazione = {\n            animazione: false,\n            loop: false\n        };\n    } else {\n        if (options.animazione == null || options.animazione == undefined) options.animazione = false;\n        if (options.loop == null || options.loop == undefined) options.loop = false;\n    }\n\n    /**\n     * Valore minimo dell'asse x\n     * \n     * @name Grafico#xMin\n     * @type {number}\n     * @default -20\n     */\n    this.xMin = options.assi[0].min;\n    /**\n     * Valore massimo dell'asse x\n     * \n     * @name Grafico#xMax\n     * @type {number}\n     * @default 20\n     */\n    this.xMax = options.assi[0].max;\n    /**\n     * Valore minimo dell'asse y\n     * \n     * @name Grafico#yMin\n     * @type {number}\n     * @default -20\n     */\n    this.yMin = options.assi[1].min;\n    /**\n     * Valore massimo dell'asse y\n     * \n     * @name Grafico#yMax\n     * @type {number}\n     * @default 20\n     */\n    this.yMax = options.assi[1].max;\n\n    /**\n     * Indice della lettera attualmente visualizzata, serve a prendere il nome dei punti\n     * \n     * @name Grafico#indexLetteraAttuale\n     * @type {number}\n     * @default 0\n     */\n    this.indexLetteraAttuale = 0;\n    /**\n     * Ultima lettera utilizzata\n     * \n     * @name Grafico#letteraAttuale\n     * @type {string}\n     * @default 20\n     */\n    this.letteraAttuale;\n\n    /**\n     * Parametri passati nell'URL\n     * \n     * @name Grafico#_GET\n     * @type {URLSearchParams}\n     * @default 20\n     */\n    this._GET = new URLSearchParams(window.location.search);\n    /**\n     * Funzioni da disegnare nel grafico\n     * \n     * @name Grafico#funzioni\n     * @type {Array.<string>}\n     * @default []\n     */\n    this.funzioni = JSON.parse(this._GET.get('funzioni'));\n\n\n    /**\n     * punti da disegnare nel grafico\n     * \n     * @name Grafico#punti\n     * @type {Array.<Punto>}\n     * @default []\n     */\n    this.punti = this._GET.get('punti');\n\n    if (this.punti) { // Se ci sono punti\n        this.punti = JSON.parse(this.punti); // Parso l'array\n    }\n\n    let puntiGrafico = [];\n    let funzioniGrafico = null;\n    let assiGrafico = [];\n\n    // Carico il grafico\n    let mathbox = mathBox({\n        plugins: ['core', 'controls', 'cursor', 'mathbox', 'fullscreen'],\n        controls: { klass: THREE.OrbitControls }\n    });\n    if (mathbox.fallback) throw 'WebGL not supported';\n\n    let three = mathbox.three;\n    three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);\n\n    let camera = mathbox.camera({\n        proxy: true,\n        position: [0, 0, 3],\n    });\n\n    // Asse cartesione\n    let view = mathbox.cartesian({\n        //range: [[-2, 2], [-1, 1]],\n        range: [\n            [this.xMin, this.xMax],\n            [this.yMin, this.yMax]\n        ],\n        scale: [3, 1.5],\n    });\n\n    // Carico la griglia\n    let griglia = view.grid({ width: 1, divideX: 40, divideY: 20, opacity: 0.25 });\n    mathbox.set('focus', options.focus);\n\n    // Carico gli assi\n    let assii = [];\n\n    options.assi.forEach((asse, i) => {\n        assii.push(view.axis({\n            axis: (i + 1),\n            width: 3,\n            detail: asse.max * 2,\n            color: options.colori.assi\n        }));\n    });\n\n    // Carico tutte le funzioni\n    console.log('funzioni', this.funzioni);\n    let funcs = this.funzioni;\n\n    funzioniGrafico = view.interval({\n        expr: function(emit, x, i, t) {\n            funcs.forEach(funzione => {\n                const y = math.parse(funzione.trim().replace('y=', '').replace('x=', '')).evaluate({\n                    x: x\n                });\n\n                emit(x, y);\n            });\n        },\n        // Numero di x per cui trovare la y\n        width: 64,\n        // 2 = 2D, 3 = 3D\n        channels: 2,\n        items: funcs.length\n    });\n\n    let curve =\n        view.line({\n            width: 4,\n            color: options.colori.funzione,\n        });\n\n    let points =\n        view.point({\n            size: 5,\n            color: options.colori.puntiFunzione,\n        });\n\n    let ticks =\n        view.ticks({\n            width: 5,\n            size: 15,\n            color: options.colori.testo,\n        });\n\n    /*let format =\n        view.format({\n            digits: 2,\n            weight: 'bold',\n        });\n\n    let labels =\n        view.label({\n            color: options.colori.testo,\n            zIndex: 1,\n        });*/\n\n    options.assi.forEach((asse, i) => {\n        const nomi = ['x', 'y'];\n        const offset = [\n            [25, 0],\n            [0, 25]\n        ];\n        const offsetTicks = [\n            [0, 40],\n            [40, 0]\n        ];\n        const coordinate = [\n            [this.xMax, 0],\n            [0, this.yMax]\n        ];\n\n        const scala = view.scale({\n            axis: (i + 1),\n            divide: asse.max / 2,\n            nice: true,\n            zero: i == 0\n        });\n        const ticks = view.ticks({\n            width: 5,\n            size: 15,\n            color: options.colori.testo,\n            zBias: 2\n        });\n        const ticksLabel = view.label({\n            color: options.colori.testo,\n            zIndex: 1,\n            offset: offsetTicks[i],\n            points: scala,\n            text: view.format({\n                digits: 2,\n                font: options.font,\n                weight: 'bold',\n                style: 'normal',\n                source: scala,\n            })\n        });\n        const label = view.label({\n            text: view.text({\n                width: 1,\n                data: [nomi[i]],\n                font: options.font,\n                weight: 'bold',\n                style: 'normal'\n            }),\n            points: view.array({\n                width: 1,\n                channels: 2,\n                data: [\n                    coordinate[i]\n                ]\n            }),\n            size: 16,\n            color: options.colori.testo,\n            outline: 0,\n            background: 'transparent',\n            offset: offset[i],\n            zIndex: 1\n        });\n\n        assiGrafico.push({\n            asse: assii[i],\n            scala: scala,\n            ticks: ticks,\n            ticksLabel: ticksLabel,\n            label: label\n        });\n    });\n\n    console.log('assiGrafico', assiGrafico);\n\n    if (this.punti) { // Se ci sono punti\n        // Li aggiungo nel grafico\n        this.punti.forEach(punto => {\n            // Prendo la lettera successiva per dare il nome al punto\n            const nomePunto = this.letteraAttuale ? String.fromCharCode(this.letteraAttuale.charCodeAt(this.letteraAttuale.length - 1) + 1) : 'A';\n            this.letteraAttuale = nomePunto;\n\n            console.log(`${nomePunto}(${punto.x}; ${punto.y})`);\n\n            puntiGrafico.push(view.label({\n                text: view.text({ width: 1, data: [nomePunto], font: options.font, weight: 'bold', style: 'normal' }),\n                points: view.array({\n                    width: 1,\n                    channels: 2,\n                    data: [\n                        [punto.x, punto.y]\n                    ]\n                }),\n                size: 30,\n                color: punto.foreground ? punto.foreground : options.colori.punti, // Se questo punto ha un colore di testo uso quello\n                outline: 1,\n                background: punto.background ? punto.background : 'transparent', // Se questo punto ha un colore di sfondo uso quello\n                offset: [10, 10],\n                zIndex: 1\n            }));\n\n            this.indexLetteraAttuale++;\n        });\n    }\n\n    // Animazione\n    if (options.animazione.animazione) { // Se devo avere un'animazione\n        mathbox.play({\n            target: 'cartesian',\n            pace: 5,\n            to: 2,\n            loop: options.animazione.loop,\n            script: [{\n                    props: {\n                        range: [\n                            [-2, 2],\n                            [-1, 1]\n                        ]\n                    }\n                },\n                {\n                    props: {\n                        range: [\n                            [-4, 4],\n                            [-2, 2]\n                        ]\n                    }\n                },\n                {\n                    props: {\n                        range: [\n                            [-2, 2],\n                            [-1, 1]\n                        ]\n                    }\n                },\n            ]\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack://mathsolver/./src/js/grafico.js?");

/***/ }),

/***/ "./src/js/mathsolver.js":
/*!******************************!*\
  !*** ./src/js/mathsolver.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MathSolver\": () => (/* binding */ MathSolver)\n/* harmony export */ });\n/* harmony import */ var _funzione__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./funzione */ \"./src/js/funzione.js\");\n\nwindow.Funzione = _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione;\n\nString.prototype.isAlpha = function() {\n    return this.match('^[a-zA-Z\\(\\)]+$');\n};\n\n/**\n * Punto da visualizzare nel grafico\n * \n * @typedef {Object} Punto\n * @property {string} x - Ascissa del punto\n * @property {string} y - Ordinata punto\n * @property {string} nome - Nome del punto (opzionale)\n * @property {string} background - Colore di sfondo del punto (opzionale)\n * @property {string} foreground - Colore di testo del punto (opzionale)\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Risultato di una scomposizione\n * \n * @typedef {Object} RisultatoScomposizione\n * @property {string} equazioneScomposta - Equazione scomposta, come stringa\n * @property {string} scomposizione - Codice HTML da inserire dentro un elemento per visualizzare i passaggi della scomposizione\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Opzioni per il disegno del grafico con MathSolver\n * \n * @typedef {Object} MathSolverGraficoOptions\n * @property {HTMLElement} elemento - Elemento del frame dove viene visualizzato il grafico\n * @property {string} pagina - Pagina html dove viene visualizzato il grafico, da inserire all'interno del frame\n * @property {boolean} punti - Se aggiungere i punti nel grafico o no\n * @property {boolean} asintoti - Se visualizzare anche gli asintoti nel grafico\n * @property {boolean} direttrice - Se visualizzare anche la direttrice nel grafico (solamente nella parabola)\n * @property {boolean} asse - Se visualizzare anche l'asse nel grafico (solamente nella parabola)\n * @property {boolean} vertice - Se visualizzare anche il vertice nel grafico (solamente nella parabola)\n * @property {boolean} fuoco - Se visualizzare anche il fuoco nel grafico (solamente nella parabola)\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Opzioni per il disegno del grafico con MathSolver\n * \n * @typedef {Object} MathSolverElementiOptions\n * @property {HTMLElement} listaPunti - Lista non ordinata dove inserire i punti\n * @property {HTMLElement} passaggiScomposizione - Elemento dove vengono visualizzati i passaggi della scomposizione    (es. '#scomposizione')\n * @property {HTMLElement} equazioniRisolte - Elemento dove vengono visualizzata la risoluzione di equazioni per risolverne una di grado maggiore   (es. '#equazioni-risolte')\n * @property {HTMLElement} risultato - Elemento dove viene visualizzato il risultato\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo MathSolver.\n * Prende tutte le opzioni necessarie per disegnare le funzioni ecc...\n * \n * @typedef {Object} MathSolverOptions\n * @property {MathSolverGraficoOptions} grafico - Opzioni del grafico\n * @property {MathSolverElementiOptions} elementi - Elementi dove inserire i valori\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Libreria che permette di eseguire diverse operazioni matematiche, come la risoluzione di equazioni e l'intersezione con gli assi\n * \n * @class MathSolver\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @param {MathSolverOptions} options Opzioni per inizializzare MathSolver\n * @version 1.0\n */\nfunction MathSolver(options) {\n    /**\n     * Lettera attualemente scelta e stampata a schermo\n     * \n     * @name MathSolver#letteraAttuale\n     * @type {string}\n     */\n    this.letteraAttuale;\n    /**\n     * Elenco completo dei punti visualizzati sullo schermo\n     * \n     * @name MathSolver#puntiAttivi\n     * @type {Array.<Punto>}\n     */\n    this.puntiAttivi = [];\n\n    /**\n     * Metodo che aggiunge un punto nello schermo\n     * \n     * @method\n     * @name MathSolver#aggiungiPunto\n     * @param {string} x Funzioni da disegnare a schermo\n     * @param {string} y Eventuali punti da aggiungere al grafico\n     * @param {string} [nome] Nome del punto\n     */\n    this.aggiungiPunto = function(x, y, nome) {\n        if (this.puntiAttivi.filter(punto => punto.x == x && punto.y == y).length == 0) { // Se questo punto non esiste già\n            // Lo aggiungo\n            this.puntiAttivi.push({\n                x: x,\n                y: y\n            });\n\n            // Prendo la lettera successiva per dare il nome al punto\n            const nomePunto = this.letteraAttuale ? String.fromCharCode(this.letteraAttuale.charCodeAt(this.letteraAttuale.length - 1) + 1) : 'A';\n            this.letteraAttuale = nomePunto;\n            let code = `${document.querySelector(options.elementi.listaPunti).innerHTML}<li style=\"list-style-type: none;\">`;\n            code += this.toLatex(`${nomePunto}(${MathSolver.numeroRazionale(x)}, ${MathSolver.numeroRazionale(y)})`);\n            code += `</li>`;\n            document.querySelector(options.elementi.listaPunti).innerHTML = code;\n        }\n    }\n\n    /**\n     * Metodo che svuota la lista dei punti aggiunti\n     * \n     * @method\n     * @name MathSolver#pulisciPunti\n     */\n    this.pulisciPunti = function() {\n        document.querySelector(options.elementi.listaPunti).innerHTML = '';\n        this.letteraAttuale = null;\n        this.puntiAttivi.length = 0;\n    }\n\n    /**\n     * Metodo che nasconde il risultato dallo schermo\n     * \n     * @method\n     * @name MathSolver#togliRisultato\n     */\n    this.togliRisultato = function() {\n        console.log('bbb');\n        document.querySelector(options.elementi.risultato).style.display = 'none';\n        document.querySelector(options.elementi.passaggiScomposizione).style.display = 'none';\n        document.querySelector(options.elementi.equazioniRisolte).style.display = 'none';\n        document.querySelector(options.elementi.passaggiScomposizione).innerHTML = '';\n        document.querySelector(options.elementi.equazioniRisolte).innerHTML = '';\n        pulisciPunti();\n    }\n\n    /**\n     * Metodo che mostra il risultato nello schermo\n     * \n     * @method\n     * @name MathSolver#mostraRisultato\n     */\n    this.mostraRisultato = function() {\n        document.querySelector(options.elementi.risultato).style.display = 'block';\n    }\n\n    /**\n     * Questo metodo permette di disegnare una funzione in un grafico richiamando una pagina impostata nelle opzioni di MathSolver.\n     * Prende come parametro solamente la funzione da visualizzare oppure un array di funzioni\n     * \n     * @method\n     * @name MathSolver#disegnaFunzione\n     * @param {string|Array.<string>} funzioni Funzioni da disegnare a schermo\n     * @param {Array.<Punto>} [punti] Eventuali punti da aggiungere al grafico\n     */\n    this.disegnaFunzione = function(funzioni, punti) {\n        try {\n            if (typeof(funzioni) == 'string') { // Se è stata passata una sola stringa\n                funzioni = [funzioni]; // Lo trasformo in array\n            }\n\n            let url = new URL(options.grafico.pagina, `https://prova.it/`);\n            url.searchParams.append('funzioni', JSON.stringify(funzioni)); // Aggiungo le funzioni\n            // Se devo aggiungere i punti\n            if (options.grafico.punti && punti) {\n                url.searchParams.append('punti', JSON.stringify(punti)); // Aggiungo i punti\n            }\n            url = url.toString().replace('https://prova.it/', '');\n\n            console.log('url', url);\n            options.grafico.elemento.src = url; // Carico il grafico nella pagina\n        } catch (err) {\n            console.error(err);\n        }\n    }\n\n    /**\n     * Il codice Latex per essere interpretato correttamente dalla libreria MathJax deve trovarsi in mezzo ai caratteri di apertura e di chiusura.\n     * Per risolvere questo problema è stato creato questo metodo\n     * \n     * @method\n     * @name MathSolver#toLatex\n     * @param {string} string Codice Latex\n     * @param {boolean} [add=true] Se aggiungere le stringhe iniziali e finali\n     * \n     * @returns {string} Stringa di codice in Latex\n     */\n    this.toLatex = function(string, add = true) {\n        let risultato = string;\n        if (add) {\n            risultato = `\\\\[${string}\\\\]`;\n        }\n        return risultato;\n    }\n\n    /**\n     * Se il numero passato come argomento è negativo lo mette tra parentesti, altrimenti lo lascia com'è\n     * \n     * @method\n     * @name MathSolver#controllaParentesi\n     * @param {number} numero Numero da controllare\n     * \n     * @returns {string} Numero come stringa e tra parentesi se negativo\n     */\n    this.controllaParentesi = function(numero) {\n        numero = MathSolver.numeroRazionale(numero);\n\n        if (numero < 0) return `(${numero})`;\n\n        return numero.toString();\n    }\n\n    /**\n     * Questo metodo ritorna tutti i divisori di un numero, utile per la scomposizione con Ruffini\n     * \n     * @method\n     * @name MathSolver#trovaDivisori\n     * @param {number} n Numero di cui trovare i divisori\n     * @param {boolean} [negativi=true] Prendere anche valori negativi\n     */\n    this.trovaDivisori = function(n, negativi = true) {\n        n = Math.abs(n); // Faccio il valore assoluto del numero\n\n        let divisori = [];\n\n        for (let i = 1; i <= parseInt(Math.sqrt(n)); i++) {\n            if (n % i == 0) {\n                if (parseInt(n / i) == i) {\n                    divisori.push(i);\n                } else {\n                    divisori.push(i);\n                    divisori.push(parseInt(n / i));\n                }\n            }\n        }\n\n        // Se devo aggiungere anche i numeri negativi\n        if (negativi) {\n            // Li aggiungo\n            divisori = divisori.concat(divisori.map(divisore => -(divisore)));\n        }\n\n        // Ordino l'array\n        divisori.sort((a, b) => a - b);\n\n        return divisori;\n    }\n\n    /**\n     * Metodo che controlla se un numero è uno zero del polinomio (ovvero che lo annulla)\n     * \n     * @method\n     * @name MathSolver#isZeroPolinomio\n     * @param {number} numero\n     * @param {string} polinomio\n     */\n    this.isZeroPolinomio = function(numero, polinomio) {\n        return math.parse(polinomio).evaluate({\n            x: numero\n        }) == 0;\n    }\n\n    /**\n     * Questo metodo scompone un'equazione utilizzando il metodo di Ruffini.\n     * Oltre a tornare il risultato visualizza a schermo i passaggi negli elementi passati nelle opzioni\n     * \n     * @method\n     * @name MathSolver#scomponiConRuffini\n     * @param {Funzione} funzione Funzione da scomporre con ruffini\n     * @returns {RisultatoScomposizione} risultato della scomposizione\n     */\n    this.scomponiConRuffini = function(funzione) {\n        let equazioneScomposta = [];\n        let scomposizione = ``;\n\n        funzione.ordina(); // Ordino la funzione in modo decrescente in base all'esponente della parte letterale\n        const polinomio = funzione.membri[0];\n        const termineNoto = funzione.termineNoto();\n        let zeroPolinomio;\n        let divisoriTermineNoto = [];\n        let divisoriICoefficiente = [];\n        let probabiliZero = [termineNoto];\n\n        if (termineNoto !== 0) { // Se c'è il termine noto\n            // Cerco i divisori del termine noto\n            divisoriTermineNoto = this.trovaDivisori(funzione.termineNoto());\n        }\n\n        /*\n        I probabili sono:\n        - Termine noto\n        - Divisori del termine noto\n        - Primo coefficiente\n        - Divisori del I coefficiente (con segno +)\n        - Rapporti tra divisori del termine noto e divisori del I coefficiente\n        */\n        // Aggiungo i divisori del termine noto\n        probabiliZero = probabiliZero.concat(divisoriTermineNoto);\n        // Aggiungo il primo coefficiente\n        probabiliZero = probabiliZero.concat(funzione.termini[0].coefficiente);\n        // Aggiungo i divisori del I coefficiente\n        divisoriICoefficiente = this.trovaDivisori(funzione.termini[0].coefficiente, false);\n        probabiliZero = probabiliZero.concat(divisoriICoefficiente);\n        // Aggiungo i rapporti tra i divisori del termine noto e i divisori del I coefficiente\n        // Per ogni divisore del termine noto\n        for (let divisore in divisoriTermineNoto) {\n            // Per ogni divisore del primo coefficiente\n            for (let divisore2 in divisoriICoefficiente) {\n                probabiliZero.push(divisore / divisore2);\n            }\n        }\n\n        // Tra i probabili zero del polinomio, cerco quello giusto\n        for (let divisore of probabiliZero) {\n            if (this.isZeroPolinomio(divisore, polinomio)) { // Se il divisore è lo zero del polinomio\n                zeroPolinomio = divisore;\n                break;\n            }\n        }\n\n        // Se lo zero del polinomio esiste\n        if (zeroPolinomio !== undefined && zeroPolinomio !== null) {\n            // Completo il polinomio con i termini mancanti\n            funzione.completa();\n            let moltiplicazioni = ``;\n            let somme = ``;\n            let risultati = [];\n\n            let risultato = funzione.termini[0].coefficiente * (zeroPolinomio); // Moltiplico il primo coefficiente per lo zero del polinomio\n            for (let i = 1; i < funzione.termini.length; i++) { // A partire dal secondo termine\n                moltiplicazioni += `<td>${this.toLatex(risultato)}</td>`;\n                risultato = funzione.termini[i].coefficiente + risultato;\n                risultati.push(risultato);\n                somme += `<td>${this.toLatex(risultato)}</td>`;\n                risultato = risultato * (zeroPolinomio);\n            }\n\n            let griglia = `<table class=\"table tabella-ruffini text-white\">\n    <tbody>\n    <tr>\n        <td></td>`;\n\n            for (let i = 0; i < funzione.termini.length; i++) {\n                griglia += `<td>${this.toLatex(funzione.termini[i].coefficiente)}</td>`;\n            }\n\n            griglia += `</tr>\n        <tr>\n            <td>${this.toLatex(zeroPolinomio)}</td>\n            <td></td>\n            ${moltiplicazioni}\n        </tr>`;\n\n            griglia += `\n        <tr class=\"somme-ruffini\">\n            <td></td>\n            <td>${this.toLatex(funzione.termini[0].coefficiente)}</td>\n            ${somme}`;\n            griglia += `\n        </tr>\n    </tbody>\n</table>`;\n\n            // Dopo aver fatto la griglia ci creiamo più equazioni\n            risultati = [funzione.termini[0].coefficiente].concat(risultati);\n            let exp = funzione.grado() - 1;\n            let scomposta = ``;\n            for (let i = 0; i < (risultati.length - 1); i++) { // Per ogni risultato\n                if (risultati[i] !== 0) { // Se il risultato non è zero\n                    // Se il risultato è -1\n                    if (risultati[i] == -1) {\n                        if (exp !== 0) {\n                            scomposta += '-';\n                        } else {\n                            scomposta += '-1';\n                        }\n                    } else if (risultati[i] == 1) { // Se è 1\n                        // Se non è il primo risultato\n                        if (i > 0) {\n                            if (exp !== 0) {\n                                scomposta += '+';\n                            } else {\n                                scomposta += '+1';\n                            }\n                        }\n                    } else { // Altrimenti\n                        if (risultati[i] > 0) scomposta += '+';\n                        scomposta += risultati[i];\n                    }\n                    if (exp !== 0) {\n                        if (exp !== 1) {\n                            scomposta += `x^${exp}`;\n                        } else {\n                            scomposta += `x`;\n                        }\n                    }\n                }\n                exp--;\n            }\n            equazioneScomposta.push(scomposta);\n\n            // Divido il polinomio per \"x-(x1)\" dove \"x1\" è lo zero del polinomio\n            let controllaMeno = ``;\n            // Se lo zero del polinomio è negativo\n            if (zeroPolinomio < 0) {\n                controllaMeno = `\\\\frac {${polinomio}} {x+${Math.abs(zeroPolinomio)}}`;\n                equazioneScomposta.push(`x+${Math.abs(zeroPolinomio)}`);\n            } else {\n                equazioneScomposta.push(`x-${zeroPolinomio}`);\n            }\n\n            let equazioneScompostaString = ``;\n            equazioneScomposta.forEach(eq => {\n                equazioneScompostaString += `(${eq})`;\n            });\n\n            scomposizione += `<div class=\"col d-flex justify-content-center\">\n    <div class=\"card bg-primary text-white mb-4\">\n        <div class=\"card-header\">${this.toLatex('\\\\text{Scomposizione con Ruffini}')}</div>\n        <div class=\"card-body\">\n            ${this.toLatex('\\\\frac {' + polinomio + '}' + ' {x-' + this.controllaParentesi(zeroPolinomio) + '}' + (controllaMeno !== '' ? ' = ' + controllaMeno : ' '))}\n        \n            <br>\n            ${griglia}\n            <br>\n            ${this.toLatex(equazioneScompostaString)}\n        </div>\n    </div>\n</div>`;\n        }\n\n        return {\n            equazione: equazioneScomposta,\n            scomposizione: scomposizione\n        };\n    }\n\n    /**\n     * Questo metodo scompone un'equazione trovando il metodo migliore per scomporla\n     * \n     * @method\n     * @name MathSolver#scomponi\n     * @param {Funzione} funzione Funzione da scomporre\n     */\n    this.scomponi = function(funzione) {\n        // Prima di utilizzare la scomposizione con Ruffini provo con altri metodi di scomposizione\n\n        // Se devo scomporre con Ruffini\n        return this.scomponiConRuffini(funzione);\n    }\n\n    /**\n     * Questo metodo risolve le equazioni di grado superiore al 2, è stato scritto per dividere la risoluzione di equazioni semplici da queste\n     * \n     * @method\n     * @name MathSolver#risolviEquazioneGradiMaggiori\n     * @param {string} equazione Equazione da risolvere\n     * @param {number} grado Grado dell'equazione da risolvere\n     * @param {string} asse Asse con cui è stata effettuata l'intersezione\n     * @param {boolean} [sistema=true] Se risolvere e basta o fare il sistema\n     * @param {booolean} [pulisci=true] Se pulire i div\n     */\n    this.risolviEquazioneGradiMaggiori = function(equazione, grado, asse, sistema = true, pulisci = true) {\n        let risultati = [];\n\n        if (pulisci) {\n            document.querySelector(options.elementi.passaggiScomposizione).innerHTML = '';\n            document.querySelector(options.elementi.equazioniRisolte).innerHTML = '';\n        }\n\n        const scomposta = this.scomponi(new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(equazione));\n        // Se l'equazione è scomponibile stampo a schermo la scomposizione\n        if (scomposta.scomposizione !== '') {\n            document.querySelector(options.elementi.passaggiScomposizione).innerHTML += scomposta.scomposizione;\n        }\n        let equazioneScomposta = ``;\n\n        let code = ``;\n        if (sistema) code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n        code += this.toLatex(equazione);\n        if (sistema) code += `${this.toLatex(asse)}\n</td>`;\n\n        if (scomposta.equazione.length > 0) { // Se l'equazione è stata scomposta\n            // La stampo a schermo\n            risultati = [];\n            let equazioniScomposte = [];\n\n            for (let i = 0; i < scomposta.equazione.length; i++) { // per ogni equazione trovata\n                // La risolvo e mi salvo i risultati\n                equazioneScomposta += `(${scomposta.equazione[i]})`;\n                const equazioneRisolta = this.risolviEquazione(`${scomposta.equazione[i]}=0`, null, asse, false, false);\n                // Mostro a schermo i passaggi per la risoluzione dell'equazione\n                document.querySelector(options.elementi.equazioniRisolte).innerHTML += `<div class=\"col-md-6\">\n    <div class=\"card bg-primary text-white mb-4\">\n        <div class=\"card-header\">${this.toLatex('\\\\text{Risoluzione equazione}')}</div>\n        <div class=\"card-body\">\n            ${equazioneRisolta.code}\n        </div>\n    </div>\n</div>`;\n                risultati = risultati.concat(equazioneRisolta.risultati);\n                if (equazioneRisolta.equazioneScomposta) { // Se è presente un'equazione scomposta\n                    equazioniScomposte.push(equazioneRisolta.equazioneScomposta);\n                }\n            }\n\n            // VIsualizzo a schermo i passaggi\n            document.querySelector(options.elementi.passaggiScomposizione).style.display = 'block';\n            document.querySelector(options.elementi.equazioniRisolte).style.display = 'flex';\n\n            /*console.log(document.querySelector(options.elementi.passaggiScomposizione));\n            console.log(document.querySelector(options.elementi.equazioniRisolte));*/\n\n            equazioneScomposta += `=0`;\n            // Visualizzo a schermo l'equazione scomposta\n            if (sistema) code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n            code += this.toLatex(`${equazioneScomposta}`);\n            if (sistema) code += `${this.toLatex(asse)}\n</td>`;\n\n            // Visualizzo a schermo le altre scomposizioni\n            if (sistema) {\n                let ultimaDaConcatenare;\n\n                if (scomposta.equazione.length > 0) { // Se l'equazione è stata scomposta\n                    ultimaDaConcatenare = `(${scomposta.equazione[scomposta.equazione.length - 1]})`;\n                }\n\n                equazioniScomposte.forEach(eq => {\n                    eq = eq.split('=')[0]; // Prendo il primo membro dell'equazione\n                    eq = `${eq}${ultimaDaConcatenare}`; // Concateno\n\n                    code += `<td class=\"spazio-sistema\"></td>\n                <td class=\"graffa-sistema\">`;\n                    code += this.toLatex(`${eq}=0`);\n                    code += `${this.toLatex(asse)}\n                </td>`;\n\n                    ultimaDaConcatenare = eq;\n                });\n            }\n\n            // Rimuovo i doppioni dai risultati\n            risultati = [...new Set(risultati)];\n\n            // Ordino l'array di risultati\n            risultati.sort((a, b) => a - b);\n\n            risultati.forEach((risultato, i) => {\n                if (sistema) code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n                code += this.toLatex('x_\\{' + (i + 1) + '\\} = ' + MathSolver.numeroRazionale(risultato));\n                if (sistema) code += this.toLatex('y_\\{' + (i + 1) + '\\} = 0');\n                if (sistema) code += `\n</td>`;\n            });\n        } else { // Altrimenti\n            if (sistema) {\n                code += `<td class=\"spazio-sistema\"></td>\n            <td>${this.toLatex('\\\\text{Impossibile scomporre l\\'equazione}')}</td>`;\n            } else {\n                code += this.toLatex('\\\\text{Impossibile scomporre l\\'equazione}');\n            }\n        }\n\n        return {\n            code: code,\n            risultati: risultati,\n            equazioneScomposta: equazioneScomposta\n        };\n    }\n\n    /**\n     * Risolve un'equazione di qualunque grado.\n     * Quando un'equazione è di grado superiore al secondo chiama un'altra funzione che la risolve in un altro modo\n     * \n     * @method\n     * @name MathSolver#controllaParentesi\n     * @param {string} equazione Equazione da risolvere\n     * @param {number} grado Grado dell'equazione\n     * @param {string} asse Asse con cui è stata fatta l'intersezione\n     * @param {boolean} [sistema=true] Se risolvere e basta o fare il sistema\n     * @param {boolean} [pulisci=true] Se pulire i div\n     * @returns {*} Risultati dell'equazione e il codice da stampare a schermo\n     */\n    this.risolviEquazione = function(equazione, grado, asse, sistema = true, pulisci = true) {\n        // Prendiamo le informazioni di questa equazione\n        let espressione = new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(equazione.split('=')[0]);\n        let code = ``;\n        let risultati = [];\n        grado = grado || espressione.grado();\n\n        switch (grado) {\n            case 1:\n                if (pulisci) {\n                    document.querySelector(options.elementi.passaggiScomposizione).style.display = 'none';\n                    document.querySelector(options.elementi.equazioniRisolte).style.display = 'none';\n                }\n\n                if (sistema) code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n                code += this.toLatex(equazione);\n                if (sistema) code += `${this.toLatex(asse)}\n</td>`;\n\n                const termineNoto = espressione.termineNoto();\n\n                if (termineNoto !== 0) { // Se il termine noto è 0\n                    // Sposto il termine noto al secondo membro\n                    if (sistema) code += `<td class=\"spazio-sistema\"></td>\n                <td class=\"graffa-sistema\">`;\n                    code += this.toLatex(espressione.termini[0].toString() + ' = ' + MathSolver.numeroRazionale(-(termineNoto)));\n                    if (sistema) code += `${this.toLatex(asse)}\n                </td>`;\n\n                    // Divido il secondo membro per il coefficiente della x\n                    // Se il coefficiente è diverso da 1\n                    let ascissa = MathSolver.numeroRazionale(Math.round((-(termineNoto) / espressione.termini[0].coefficiente) * 100, 2) / 100);\n                    let ordinata = asse.split('=')[1];\n\n                    if (espressione.termini[0].coefficiente !== 1) {\n                        if (sistema) code += `<td class=\"spazio-sistema\"></td>\n                    <td class=\"graffa-sistema\">`;\n                        code += this.toLatex('x = ' + ascissa);\n                        if (sistema) code += `${this.toLatex(asse)}\n                    </td>`;\n                    }\n\n                    this.aggiungiPunto(ascissa, ordinata);\n\n                    risultati = [ascissa];\n                } else { // Altrimenti\n                    if (sistema) code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n                    code += this.toLatex('x = 0');\n                    if (sistema) code += `${this.toLatex(asse)}\n</td>`;\n                    this.aggiungiPunto(0, 0);\n                }\n                break;\n            case 2:\n                if (pulisci) {\n                    document.querySelector(options.elementi.passaggiScomposizione).style.display = 'none';\n                    document.querySelector(options.elementi.equazioniRisolte).style.display = 'none';\n                }\n\n                if (sistema) code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">`;\n                code += this.toLatex(equazione);\n                if (sistema) code += `${this.toLatex(asse)}\n</td>`;\n                const a = espressione.getByExp(2);\n                const b = espressione.getByExp(1);\n                const c = espressione.termineNoto();\n                const delta = Math.pow((b ? b.coefficiente : 0), 2) - (4 * a.coefficiente * c);\n                const radice = Math.sqrt(delta);\n                risultati = [\n                    (-(b ? b.coefficiente : 0) - radice) / 2 * a.coefficiente,\n                    (-(b ? b.coefficiente : 0) + radice) / 2 * a.coefficiente\n                ];\n\n                // Stampo la formula\n                if (sistema) code += `<td class=\"spazio-sistema\"></td>\n                <td class=\"graffa-sistema\">`;\n                code += this.toLatex(`x = \\\\frac{-b \\\\pm \\\\sqrt{b^2-4ac}} {2a}`);\n\n                if (sistema) code += `${this.toLatex(asse)}\n                </td>`;\n                // Stampo l'equazione con i numeri sostituiti\n                if (sistema) code += `<td class=\"spazio-sistema\"></td>\n                <td class=\"graffa-sistema\">`;\n                code += this.toLatex(`x = \\\\frac{-${this.controllaParentesi((b ? b.coefficiente : 0))} \\\\pm \\\\sqrt{${this.controllaParentesi((b ? b.coefficiente : 0))}^2-4*${this.controllaParentesi(a.coefficiente)}*${this.controllaParentesi(c)}}} {${this.controllaParentesi(a.coefficiente * 2)}} = 0`);\n\n                if (sistema) code += `${this.toLatex(asse)}\n                </td>`;\n                // Stampo l'equazione con il delta trovato\n                if (sistema) code += `<td class=\"spazio-sistema\"></td>\n                <td class=\"graffa-sistema\">`;\n\n                code += this.toLatex(`x = \\\\frac{-${this.controllaParentesi((b ? b.coefficiente : 0))} \\\\pm \\\\sqrt{${MathSolver.numeroRazionale(delta)}}} {${this.controllaParentesi(a.coefficiente * 2)}}`);\n\n                if (sistema) code += `${this.toLatex(asse)}\n                </td>`;\n                if (delta < 0) { // Se il delta è minore di zero\n                    // L'equazione è impossibile\n                    // Stampo l'equazione con la radice risolta\n                    if (sistema) code += `<td class=\"spazio-sistema\"></td>\n            \n            <td class=\"graffa-sistema\">`;\n                    code += this.toLatex('\\\\text{eq. imp. in } \\\\mathbb{R}');\n\n                    if (sistema) code += `${this.toLatex(asse)}\n            </td>`;\n                } else { // Altrimenti\n                    // Stampo l'equazione con la radice risolta\n                    if (sistema) code += `<td class=\"spazio-sistema\"></td>\n            \n            <td class=\"graffa-sistema\">`;\n                    code += this.toLatex(`x = \\\\frac{-${this.controllaParentesi((b ? b.coefficiente : 0))} \\\\pm ${MathSolver.numeroRazionale(radice)}} {${this.controllaParentesi(a.coefficiente)}}`);\n                    if (sistema) code += `${this.toLatex(asse)}\n            </td>`;\n\n                    // Se il delta è uguale a zero\n                    if (delta == 0) {\n                        // Stampo il risultato\n                        if (sistema) code += `<td class=\"spazio-sistema\"></td>\n            \n            <td class=\"graffa-sistema\">`;\n                        code += this.toLatex('x_\\{1,2\\} = \\\\pm' + MathSolver.numeroRazionale(Math.abs(risultati[0])));\n\n                        if (sistema) code += `${this.toLatex(asse)}\n            </td>`;\n                        this.aggiungiPunto(risultati[0], 0);\n                    } else {\n                        // Stampo i risultati\n                        for (let i = 0; i < 2; i++) {\n                            if (sistema) code += `<td class=\"spazio-sistema\"></td>\n                        \n                        <td class=\"graffa-sistema\">`;\n                            code += this.toLatex('x_\\{' + (i + 1) + '\\} = ' + MathSolver.numeroRazionale(risultati[i]));\n                            if (sistema) code += this.toLatex('y_\\{' + (i + 1) + '\\} = 0');\n                            if (sistema) code += `</td>`;\n                            this.aggiungiPunto(risultati[i], 0);\n                        }\n                    }\n                }\n                break;\n            default:\n                return this.risolviEquazioneGradiMaggiori(equazione, grado, asse, sistema, pulisci);\n        }\n\n        return {\n            code: code,\n            risultati: risultati\n        };\n    }\n\n    /**\n     * Effettua l'intersezione di una funzione con un determinato asse\n     * \n     * @method\n     * @name MathSolver#intersezioneAsse\n     * @param {string} funzione Funzione presa in input\n     * @param {string} asse Asse con cui la funzione deve fare l'intersezione\n     */\n    this.intersezioneAsse = function(funzione, asse) {\n        const equazioniAssi = {\n            x: 'y = 0',\n            y: 'x = 0'\n        };\n\n        let code = `<h5>${this.toLatex('\\\\text{Intersezione con l\\'asse ' + asse + '}')}</h5>\n<table tborder=0>\n    <tbody>\n        <tr>\n            \n            <td class=\"graffa-sistema\">\n                ${this.toLatex(funzione)}\n                \n                ${this.toLatex(equazioniAssi[asse])}\n            </td>`;\n\n        funzione = new _funzione__WEBPACK_IMPORTED_MODULE_0__.Funzione(funzione); // Interpretiamo la funzione in un oggetto\n\n        if (asse == 'y') { // Se devo fare l'intersezione con l'asse y\n            const termineNoto = funzione.termineNoto();\n            code += `<td class=\"spazio-sistema\"></td>\n<td class=\"graffa-sistema\">\n    ${this.toLatex('y = ' + MathSolver.numeroRazionale(termineNoto))}\n    ${this.toLatex(equazioniAssi[asse])}\n</td>`;\n            this.aggiungiPunto(0, termineNoto);\n        } else {\n            code += this.risolviEquazione(`${funzione.membri[1]}=0`, funzione.grado(), equazioniAssi[asse]).code;\n        }\n\n        code += `\n        </tr>\n    </tbody>\n<table>`;\n        return code;\n    }\n\n}\n\n/**\n * Divide l'espressione in ogni termine di cui è composta in base a dei caratteri delimitanti\n * \n * @param {string} espressione \n * @param {Array.<string>} caratteri Caratteri delimitanti\n * @name MathSolver#splittaEspressione\n * @static\n */\nMathSolver.splittaEspressione = function(espressione, caratteri) {\n    let split = [];\n    let stringa = '';\n\n    for (let i = 0; i < espressione.length; i++) { // leggo ogni carattere dell'espressione\n        const carattere = espressione[i];\n\n        if (!caratteri.includes(espressione[i]) || i == 0) { // Se non è un carattere da splittare e non è il primo carattere dell'espressione\n            stringa += espressione[i];\n        } else {\n            split.push(stringa); // Aggiungiamo la stringa nell'array\n            stringa = `${carattere}`; // Svuotiamo la stringa\n        }\n\n        if (i == (espressione.length - 1)) { // Se sono all'ultimo carattere e non ho trovato nulla da splittare\n            split.push(stringa); // Aggiungiamo la stringa nell'array\n        }\n    }\n\n    return split;\n}\n\n/**\n * Metodo che ritorna il numero sotto forma di frazione.\n * Al momento questa funzione non fa nulla per continuare il corretto funzionamento del programma in quanto ci sono degli errori\n * \n * @method\n * @name MathSolver#numeroRazionale\n * @param {number} value Numero da controllare\n * @returns {*} Numero sotto forma di frazione\n * @static\n */\nMathSolver.numeroRazionale = function(value) {\n    return value;\n    /*const frazione = math.fraction(math.number(value));\n    if (frazione.d !== 1) {\n        return `\\\\frac{${frazione.n.toString()}} {${frazione.d.toString()}}`;\n    } else {\n        return value;\n    }*/\n}\n\n\n\n//# sourceURL=webpack://mathsolver/./src/js/mathsolver.js?");

/***/ }),

/***/ "./src/js/parte-letterale.js":
/*!***********************************!*\
  !*** ./src/js/parte-letterale.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParteLetterale\": () => (/* binding */ ParteLetterale)\n/* harmony export */ });\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo ParteLetterale\n * \n * @typedef {Object} ParteLetteraleOptions\n * @property {string} lettera - Lettera della parte letterale\n * @property {number} esponente - Esponente della parte letterale\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Questa classe serve a definire la parte letterale intpretata da un'espressione, letta come stringa\n * \n * @class ParteLetterale\n * @classdesc ParteLetterale di un termine\n * @param {ParteLetteraleOptions|string} options Opzioni per inizializzare la parte letterale\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\nfunction ParteLetterale(options) {\n    /**\n     * Letterale della parte letterale\n     * \n     * @name ParteLetterale#lettera\n     * @type {string}\n     * @default 0\n     */\n    this.lettera = null;\n    /**\n     * Esponente della parte letterale\n     * \n     * @name ParteLetterale#esponente\n     * @type {number}\n     * @default {}\n     */\n    this.esponente = 0;\n\n    switch (typeof(options)) { // In base al tipo di dato delle opzioni che sono state passate\n        case 'string': // Se ha passato una stringa\n            // Intrepreto la stringa e mi prendo i dati necessari\n            ParteLetterale.interpreta(options, this);\n            break;\n        default: // Se ha passato un oggetto di tipo ParteLetteraleOptions\n            // Prendo le opzioni\n            this.lettera = options.lettera;\n            this.esponente = options.esponente;\n    }\n\n    /**\n     * Metodo che ritorna la parte letterale come stringa.\n     * Molto utile nel caso in cui la parte letterale sia stata modificata da uno dei metodi per poterlo stampare a schermo con le modifiche\n     * \n     * @method\n     * @name ParteLetterale#toString\n     * @returns {string} Parte letterale scritta sotto forma di stringa\n     */\n    this.toString = function() {\n        if (this.esponente !== 0) {\n            if (this.esponente !== 1) {\n                return `${this.lettera}^${this.esponente}`;\n            } else {\n                return `${this.lettera}`;\n            }\n        } else {\n            return this.lettera;\n        }\n    }\n}\n\n/**\n * Interpreta la parte letterale scritta come stringa.\n * Serve nel caso in cui si passi una stringa al costruttore e si voglia fare il passaggio di interpretazione in automatico\n * \n * @param {string} parteLetterale Parte letterale da intepretare\n * @param {ParteLetterale} [obj] Oggetto da modificare\n * @name ParteLetterale#interpreta\n * @static\n * @returns {ParteLetterale} Parte letterale interpretata\n */\nParteLetterale.interpreta = function(parteLetterale, obj) {\n    // Se non c'è nessuna parte letterale\n    if (parteLetterale == null) {\n        if (obj) { // Se devo modificare un oggetto\n            obj = null;\n        }\n\n        return null;\n    }\n\n    let split = parteLetterale.split('^');\n    let esponente = 1;\n    let lettera = split[0];\n\n    if (split.length > 1) {\n        esponente = parseFloat(split[1]);\n    }\n\n    if (obj) { // Se devo modificare un oggetto\n        obj.lettera = lettera;\n        obj.esponente = esponente;\n\n        return obj;\n    } else { // Altrimenti\n        return new ParteLetterale({\n            lettera: lettera,\n            esponente: esponente\n        });;\n    }\n}\n\n\n\n//# sourceURL=webpack://mathsolver/./src/js/parte-letterale.js?");

/***/ }),

/***/ "./src/js/termine.js":
/*!***************************!*\
  !*** ./src/js/termine.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Termine\": () => (/* binding */ Termine)\n/* harmony export */ });\n/* harmony import */ var _parte_letterale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parte-letterale */ \"./src/js/parte-letterale.js\");\n\nwindow.ParteLetterale = _parte_letterale__WEBPACK_IMPORTED_MODULE_0__.ParteLetterale;\n\n/**\n * Opzioni per l'inizializzazione di un oggetto di tipo Termine\n * \n * @typedef {Object} TermineOptions\n * @property {number} coefficiente - Coefficiente del termine\n * @property {ParteLetterale} parteLetterale - Parte letterale del termine\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\n\n/**\n * Questa classe serve a definire i termini interpretati da un'espressione, letta come stringa\n * \n * @class Termine\n * @classdesc Termine di un'espressione\n * @param {TermineOptions|string} options Opzioni per inizializzare un termine\n * @author Gabriele Princiotta <gabriprinciott@gmail.com>\n * @version 1.0\n */\nfunction Termine(options) {\n    /**\n     * Coefficiente del termine (il numero scritto accanto alla parte letterale)\n     * \n     * @name Termine#coefficiente\n     * @type {number}\n     * @default 0\n     */\n    this.coefficiente = 0;\n    /**\n     * Parte letterale del termine, è divisa a sua volta in lettera ed esponente\n     * \n     * @name Termine#parteLetterale\n     * @type {ParteLetterale}\n     * @default {}\n     */\n    this.parteLetterale = {};\n\n    switch (typeof(options)) { // In base al tipo di dato delle opzioni che sono state passate\n        case 'string': // Se ha passato una stringa\n            // Intrepreto la stringa e mi prendo i dati necessari\n            Termine.interpreta(options, this);\n            break;\n        default: // Se ha passato un oggetto di tipo TermineOptions\n            // Prendo le opzioni\n            this.coefficiente = options.coefficiente;\n            this.parteLetterale = options.parteLetterale;\n    }\n\n    /**\n     * Metodo che ritorna il termine come stringa.\n     * Molto utile nel caso in cui il termine sia stata modificato da uno dei metodi per poterlo stampare a schermo con le modifiche\n     * \n     * @method\n     * @returns {string} Termine scritto sotto forma di stringa\n     */\n    this.toString = function() {\n        let string;\n\n        if (this.coefficiente == 1) {\n            string = `+${this.parteLetterale.toString()}`;\n        } else if (this.coefficiente == -1) {\n            string = `-${this.parteLetterale.toString()}`;\n        } else {\n            string = MathSolver.numeroRazionale(this.coefficiente) + (this.parteLetterale ? this.parteLetterale.toString() : '')\n        }\n\n        return string;\n    }\n}\n\n/**\n * Interpreta un termine scritta come stringa.\n * Serve nel caso in cui si passi una stringa al costruttore e si voglia fare il passaggio di interpretazione in automatico\n * \n * @param {string} termine Termine da intepretare\n * @param {Termine} [obj] Oggetto da modificare\n * @name Termine#interpreta\n * @static\n * @returns {Termine} Termine interpretato\n */\nTermine.interpreta = function(termine, obj) {\n    let coefficiente = '';\n    let parteLetterale = '';\n    let prendiCoefficiente = true;\n\n    for (let i = 0; i < termine.length; i++) { // Leggo tutti i caratteri del termine\n        // Se è una lettera\n        if (termine[i].isAlpha()) {\n            prendiCoefficiente = false; // Smettiamo di prendere il coefficiente\n        }\n\n        if (prendiCoefficiente) { // Se posso prendere il coefficiente\n            coefficiente += termine[i];\n        } else { // Altrimenti\n            parteLetterale += termine[i];\n        }\n    }\n\n    switch (coefficiente) { // In base al valore del coefficiente\n        case '+':\n        case '':\n            // Se non c'è o è un + vale 1\n            coefficiente = 1;\n            break;\n        case '-':\n            // Se è un meno vale -1\n            coefficiente = -1;\n            break;\n        default:\n            // Altrimenti lo intrepreto come float\n            coefficiente = parseFloat(coefficiente);\n    }\n\n    if (parteLetterale == '') parteLetterale = null;\n    parteLetterale = _parte_letterale__WEBPACK_IMPORTED_MODULE_0__.ParteLetterale.interpreta(parteLetterale);\n\n    if (obj) { // Se devo modificare un oggetto\n        obj.coefficiente = coefficiente;\n        obj.parteLetterale = parteLetterale;\n\n        return obj;\n    } else { // Altrimenti\n        return new Termine({\n            coefficiente: coefficiente,\n            parteLetterale: parteLetterale\n        });;\n    }\n}\n\n\n\n//# sourceURL=webpack://mathsolver/./src/js/termine.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	__webpack_exports__ = __webpack_exports__.default;
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});